<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-18T18:16:33+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nick Choi’s Works</title><subtitle>Nick Choi&apos;s Works
</subtitle><author><name>nickchoi</name></author><entry><title type="html">Modern CMake - Introduction</title><link href="http://localhost:4000/2024/01/16/00-modern-cmake-introduction.html" rel="alternate" type="text/html" title="Modern CMake - Introduction" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/2024/01/16/00-modern-cmake-introduction</id><content type="html" xml:base="http://localhost:4000/2024/01/16/00-modern-cmake-introduction.html"><![CDATA[<p>Modern CMake 공부하려고 대충 번역 중.</p>

<h1 id="introduction">Introduction</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다</li>
      <li>CMake가 사용되는 이유를 이해한다.</li>
      <li>최신 CMake가 더 좋다.</li>
    </ul>
  </li>
</ul>

<p>코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다.</p>

<p>그래서 사람들은 <strong>빌드 시스템</strong>을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다.</p>

<p>그러나 이는 다음과 같다.</p>
<ul>
  <li>대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다.</li>
  <li>플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다.</li>
  <li>종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다.</li>
  <li>확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다.</li>
</ul>

<p>빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다.</p>

<p>CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다.</p>

<p>요약하면 다음과 같은 경우 CMake를 사용해야 한다.</p>
<ul>
  <li>하드 코딩 경로를 피하고 싶은 경우</li>
  <li>두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우</li>
  <li>CI(지속적 통합)를 사용하고 싶은 경우</li>
  <li>다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음)</li>
  <li>여러 컴파일러를 지원하고 싶은 경우</li>
  <li>IDE를 사용하고 싶지만 항상 그렇지는 않을 경우</li>
  <li>플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우</li>
  <li>라이브러리를 이용하고 싶은 경우</li>
  <li>Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우</li>
  <li>디버거를 사용하려는 경우</li>
</ul>

<h1 id="more-modern-cmake">(More) Modern CMake</h1>

<p>CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 <a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">여기</a>를 참조하라.</p>

<p>왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. <strong>모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다.</strong> CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다.</p>

<h2 id="모던-cmake의-예">모던 CMake의 예</h2>
<ul>
  <li>
    <p>잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다.</p>
  </li>
  <li>
    <p>CMake 3.1+가 필요한 경우 <strong>CXX_STANDARD</strong>를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 <strong>compile_features</strong>를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다.</p>
  </li>
  <li>
    <p>CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 <strong>compile_features</strong>를 사용하여 <strong>cxx_std_11</strong>과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다.</p>
  </li>
</ul>

<h1 id="2023년-최소한의-선택">2023년 최소한의 선택</h1>

<p>로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다.</p>

<p>지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다.</p>

<h2 id="선택할-최소-항목---os-지원">선택할 최소 항목 - OS 지원:</h2>

<ul>
  <li>3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라.</li>
  <li>3.7: Debian의 오래된 Stable.</li>
  <li>3.10: Ubuntu 18.04.</li>
  <li>3.11: CentOS 8(단, EPEL 또는 AppSteams 사용)</li>
  <li>3.13: Debian Stable.</li>
  <li>3.16: Ubuntu 20.04.</li>
  <li>3.19: 최초로 Apple Silicon을 지원.</li>
  <li>최신: pip/conda-forge/homebew/chocolaty 등</li>
</ul>

<h2 id="선택할-최소-항목---기능">선택할 최소 항목 - 기능:</h2>

<ul>
  <li>3.8: C++ 메타 기능, CUDA 등 다양한 기능</li>
  <li>3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE</li>
  <li>3.12: C++20, cmake –build build -j N, SHELL:, FindPython</li>
  <li>3.14/3.15: CLI, FindPython 업데이트</li>
  <li>3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능</li>
  <li>3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍</li>
  <li>3.20: C++23, CUDARCHS, IntelLLVM, NVHPC</li>
  <li>3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS</li>
  <li>3.24: 다운로드와 패키지 찾기 통합, –fresh</li>
  <li>3.25: C++26 지원, CUDA용 LTO</li>
</ul>

<h1 id="다른-소스들">다른 소스들</h1>

<p>웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다.</p>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/">Modern CMake</a>: 이 튜토리얼의 출처가 되는 책.</li>
  <li><a href="https://cmake.org/cmake/help/latest/">The official help</a>: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐.</li>
  <li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a>: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록.</li>
  <li><a href="https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/">Embracing Modern CMake</a>: 용어에 대한 좋은 설명이 포함된 게시물.</li>
  <li><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">It’s time to do CMake Right</a>: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음.</li>
  <li><a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/">The Ultimate Guide to Modern CMake</a>: 비슷한 의도를 지닌 약간 오래된 게시물.</li>
  <li><a href="https://youtu.be/y7ndUhdQuU8">More Modern CMake</a>: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다.</li>
  <li><a href="https://github.com/toeb/moderncmake">toeb/moderncmake</a>: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제</li>
</ul>

<h1 id="핵심사항">핵심사항</h1>

<ul>
  <li>빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다.</li>
  <li>빌드 시스템 생성기는 일반적인 관계를 설명한다.</li>
  <li>모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Modern CMake 공부하려고 대충 번역 중. Introduction Overview 질문 빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가? 목표 빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다 CMake가 사용되는 이유를 이해한다. 최신 CMake가 더 좋다. 코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다. 그래서 사람들은 빌드 시스템을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다. 그러나 이는 다음과 같다. 대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다. 플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다. 종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다. 확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다. 빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다. CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다. 요약하면 다음과 같은 경우 CMake를 사용해야 한다. 하드 코딩 경로를 피하고 싶은 경우 두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우 CI(지속적 통합)를 사용하고 싶은 경우 다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음) 여러 컴파일러를 지원하고 싶은 경우 IDE를 사용하고 싶지만 항상 그렇지는 않을 경우 플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우 라이브러리를 이용하고 싶은 경우 Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우 디버거를 사용하려는 경우 (More) Modern CMake CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 여기를 참조하라. 왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. 모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다. CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다. 모던 CMake의 예 잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다. CMake 3.1+가 필요한 경우 CXX_STANDARD를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 compile_features를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다. CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 compile_features를 사용하여 cxx_std_11과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다. 2023년 최소한의 선택 로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다. 지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다. 선택할 최소 항목 - OS 지원: 3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라. 3.7: Debian의 오래된 Stable. 3.10: Ubuntu 18.04. 3.11: CentOS 8(단, EPEL 또는 AppSteams 사용) 3.13: Debian Stable. 3.16: Ubuntu 20.04. 3.19: 최초로 Apple Silicon을 지원. 최신: pip/conda-forge/homebew/chocolaty 등 선택할 최소 항목 - 기능: 3.8: C++ 메타 기능, CUDA 등 다양한 기능 3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE 3.12: C++20, cmake –build build -j N, SHELL:, FindPython 3.14/3.15: CLI, FindPython 업데이트 3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능 3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍 3.20: C++23, CUDARCHS, IntelLLVM, NVHPC 3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS 3.24: 다운로드와 패키지 찾기 통합, –fresh 3.25: C++26 지원, CUDA용 LTO 다른 소스들 웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다. Modern CMake: 이 튜토리얼의 출처가 되는 책. The official help: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐. Effective Modern CMake: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록. Embracing Modern CMake: 용어에 대한 좋은 설명이 포함된 게시물. It’s time to do CMake Right: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음. The Ultimate Guide to Modern CMake: 비슷한 의도를 지닌 약간 오래된 게시물. More Modern CMake: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다. toeb/moderncmake: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제 핵심사항 빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다. 빌드 시스템 생성기는 일반적인 관계를 설명한다. 모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.]]></summary></entry><entry><title type="html">Modern CMake</title><link href="http://localhost:4000/2024/01/15/00-modern-cmake.html" rel="alternate" type="text/html" title="Modern CMake" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/2024/01/15/00-modern-cmake</id><content type="html" xml:base="http://localhost:4000/2024/01/15/00-modern-cmake.html"><![CDATA[<p>Modern CMake 공부하려고 대충 번역함.</p>

<hr />]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Modern CMake 공부하려고 대충 번역함.]]></summary></entry><entry><title type="html">Unity Prototype Step2</title><link href="http://localhost:4000/2023/10/26/18-unity-client-step2.html" rel="alternate" type="text/html" title="Unity Prototype Step2" /><published>2023-10-26T00:00:00+09:00</published><updated>2023-10-26T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/26/18-unity-client-step2</id><content type="html" xml:base="http://localhost:4000/2023/10/26/18-unity-client-step2.html"><![CDATA[<h1 id="2-캐릭터-클래스-정의">2. 캐릭터 클래스 정의</h1>
<ul>
  <li>프로토타입에 사용될 예제들은 페이지 마지막에 정리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : type // 인간,드워프
  Class : type // 전사, 성직자
  Level : uint // 레벨
  Movement : uint //이동 가능 칸수
  CurrentHitPoint : uint //현재 HP
  MaxHitPoint : uint //최대 HP
  Strength : uint // 힘, 일단 1
  AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스
  AttackRange : uint //공격범위, 근거리일 경우는 1
  ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11
  WeaponType : type //한손
  WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage)
}
</code></pre></div></div>

<h1 id="3-두-캐릭터의-hp-표시하기">3. 두 캐릭터의 HP 표시하기</h1>

<ul>
  <li>Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-hpbar.png" alt="캐릭터 HP" /></p>

<h1 id="4-커맨드-메뉴-구현하기">4. 커맨드 메뉴 구현하기</h1>

<ul>
  <li>해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행</li>
  <li>한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-menu.png" alt="캐릭터 메뉴" /></p>

<h2 id="1-이동">1. 이동</h2>

<ul>
  <li>이동 메뉴를 선택시 <a href="/unity-prototype-step1">이전페이지</a> 와 동일하게 이동할 수 있는 영역이 표시됨</li>
  <li>영역은 Character Class의 Movement 값을 적용하여 표시</li>
  <li>영역 클릭시 해당 타일로 이동</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-move.png" alt="캐릭터 이동" /></p>

<h2 id="2-공격">2. 공격</h2>

<ul>
  <li>영역은 Character Class의 AttackRange 값을 적용하여 표시</li>
  <li>영역 클릭시 아래 공격 로직을 적용</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-attack.png" alt="캐릭터 공격" /></p>

<h2 id="3-대기">3. 대기</h2>

<ul>
  <li>따로 영역 필요없이 상대방에게 턴을 넘김</li>
</ul>

<h1 id="5-공격-적용">5. 공격 적용</h1>
<ul>
  <li>이번에는 따로 무기없이 한손, 근거리 전투로만 한정</li>
</ul>

<h2 id="명중-굴림">명중 굴림</h2>

<ul>
  <li>공격이 성공하는지 체크하는 로직으로 <strong>공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공</strong></li>
  <li>
    <p><a href="/basic-fantasy/encounter#공격하기">Basic Fantasy - 조우</a>의 공격하기 설명 참고</p>
  </li>
  <li>명중 굴림 성공 유무 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="피해">피해</h2>

<ul>
  <li>명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영</li>
  <li>
    <p><a href="/basic-fantasy/encounter#피해">Basic Fantasy - 조우</a>의 피해 설명 참고</p>
  </li>
  <li>피해 산정 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>피해 = Math.Rand(WeaponDamage) + Strength
</code></pre></div>    </div>
  </li>
  <li>상대편 HP 적용, 상대편 HPBar에 업데이트
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CurrentHitPoint = CurrentHitPoint - 피해
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="공격턴-마무리">공격턴 마무리</h2>

<ul>
  <li>상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리</li>
</ul>

<h1 id="5-프로토타입에-적용할-chracter-예제-데이터">5. 프로토타입에 적용할 Chracter 예제 데이터</h1>
<ul>
  <li>드워프/전사</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Dwarf
  Class : Fighter
  Level : 1
  Movement : 2
  CurrentHitPoint : 15
  MaxHitPoint : 15
  Strength : 2
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 6
}
</code></pre></div></div>

<ul>
  <li>인간/성직자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Human
  Class : Cleric
  Level : 1
  Movement : 1
  CurrentHitPoint : 12
  MaxHitPoint : 12
  Strength : 1
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 4
}
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[2. 캐릭터 클래스 정의 프로토타입에 사용될 예제들은 페이지 마지막에 정리 Character { Race : type // 인간,드워프 Class : type // 전사, 성직자 Level : uint // 레벨 Movement : uint //이동 가능 칸수 CurrentHitPoint : uint //현재 HP MaxHitPoint : uint //최대 HP Strength : uint // 힘, 일단 1 AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스 AttackRange : uint //공격범위, 근거리일 경우는 1 ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11 WeaponType : type //한손 WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage) } 3. 두 캐릭터의 HP 표시하기 Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시 4. 커맨드 메뉴 구현하기 해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행 한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경 1. 이동 이동 메뉴를 선택시 이전페이지 와 동일하게 이동할 수 있는 영역이 표시됨 영역은 Character Class의 Movement 값을 적용하여 표시 영역 클릭시 해당 타일로 이동 2. 공격 영역은 Character Class의 AttackRange 값을 적용하여 표시 영역 클릭시 아래 공격 로직을 적용 3. 대기 따로 영역 필요없이 상대방에게 턴을 넘김 5. 공격 적용 이번에는 따로 무기없이 한손, 근거리 전투로만 한정 명중 굴림 공격이 성공하는지 체크하는 로직으로 공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공 Basic Fantasy - 조우의 공격하기 설명 참고 명중 굴림 성공 유무 수식 Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC 피해 명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영 Basic Fantasy - 조우의 피해 설명 참고 피해 산정 수식 피해 = Math.Rand(WeaponDamage) + Strength 상대편 HP 적용, 상대편 HPBar에 업데이트 CurrentHitPoint = CurrentHitPoint - 피해 공격턴 마무리 상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리 5. 프로토타입에 적용할 Chracter 예제 데이터 드워프/전사 Character { Race : Dwarf Class : Fighter Level : 1 Movement : 2 CurrentHitPoint : 15 MaxHitPoint : 15 Strength : 2 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 6 } 인간/성직자 Character { Race : Human Class : Cleric Level : 1 Movement : 1 CurrentHitPoint : 12 MaxHitPoint : 12 Strength : 1 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 4 }]]></summary></entry><entry><title type="html">Dotnetty Prototype Step3</title><link href="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step3" /><published>2023-10-12T00:00:00+09:00</published><updated>2023-10-12T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3</id><content type="html" xml:base="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html"><![CDATA[<h1 id="인스턴스-메신저-구현하기">인스턴스 메신저 구현하기</h1>
<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/InstantMessenger">github project</a></li>
  <li><a href="https://github.com/SoonPoong-Hong/hong-netty-messenger">Netty로 구현된 원래 프로젝트</a></li>
</ul>

<h2 id="기능-패킷-타입--enum-e_action-참고">기능 (패킷 타입) : enum E_ACTION 참고</h2>
<ul>
  <li>LOGIN  //로그인</li>
  <li>LOGOUT //로그아웃</li>
  <li>ENTER_TO_ROOM //방 입장 요청</li>
  <li>EXIT_FROM_ROOM //방 퇴장 요청</li>
  <li>TALK_MESSAGE //메시지 톡 전송</li>
  <li>ROOM_LIST //방 목록</li>
  <li>USER_LIST //방 사람들 목록</li>
  <li>RESPONSE_SUCCESS //성공 – 서버 응답으로 사용</li>
  <li>RESPONSE_FAIL //실패 – 서버 응답으로 사용</li>
</ul>

<h2 id="클라이언트-명령">클라이언트 명령</h2>
<ul>
  <li>LOGIN은 실행과 동시에 같이 처리됨으로 생략</li>
  <li>위의 패킷 타입과 동일</li>
</ul>

<h3 id="단일명령">단일명령</h3>
<ul>
  <li>끝에 :만 붙여서 처리</li>
  <li>LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST:</li>
</ul>

<h3 id="파라메터명령">파라메터명령</h3>
<ul>
  <li>: 뒤에 파라메터를 붙여 처리</li>
  <li>TALK_MESSAGE:<strong>전달할 메시지</strong></li>
  <li>ENTER_TO_ROOM:<strong>들아걸 방이름</strong></li>
</ul>

<h2 id="패킷-구조">패킷 구조</h2>
<ul>
  <li>
    <p>MessagePacket/PacketHelper 클래스 참조</p>
  </li>
  <li>Header
    <ul>
      <li>= 로 시작하고 = 로 끝남</li>
      <li>key:value로 선언되고, 각 라인은 CRLF 로 처리</li>
      <li>length:XXXX 는 Body의 길이, length가 0이면 contents가 없다.</li>
    </ul>
  </li>
  <li>Body
    <ul>
      <li>문자열로 이루어진 데이터</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>
<ul>
  <li>LOGIN 패킷의 경우 : Body가 없음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
LOGIN
length:0
refId:1
refName:nick
=
</code></pre></div>    </div>
  </li>
  <li>USER_LIST 패킷의 경우
    <ul>
      <li>[“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다.
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
USER_LIST
length:5
=
["1"]
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="pipeline-설명--클라-서버-클라">Pipeline 설명 : 클라-&gt;서버-&gt;클라</h2>
<ul>
  <li>클라 전송
    <ol>
      <li>부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화)</li>
      <li>Connect</li>
      <li>ClientConsoleInput 클래스에서 유저 입력을 받음</li>
      <li>bootstrap channel의 WriteAndFlushAsync 메소드 호출</li>
      <li>MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨</li>
    </ol>
  </li>
  <li>서버 수신
    <ol>
      <li>MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성</li>
      <li>MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리</li>
      <li>그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨</li>
      <li>처리된 결과를 <strong>클라 전송 4/5 항목과 동일하게 실행</strong>하여 전송</li>
    </ol>
  </li>
</ul>

<h2 id="서버클라이언트-콘솔-실행">서버/클라이언트 콘솔 실행</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-im-server-client.png" alt="서버-클라이언트 콘솔" /></li>
</ul>

<h3 id="서버-실행">서버 실행</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMServer
</code></pre></div></div>

<h3 id="클라-실행">클라 실행</h3>
<ul>
  <li>./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 1 nick
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 2 choi
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><category term="InstantMessenger" /><summary type="html"><![CDATA[인스턴스 메신저 구현하기 소스코드 github project Netty로 구현된 원래 프로젝트 기능 (패킷 타입) : enum E_ACTION 참고 LOGIN //로그인 LOGOUT //로그아웃 ENTER_TO_ROOM //방 입장 요청 EXIT_FROM_ROOM //방 퇴장 요청 TALK_MESSAGE //메시지 톡 전송 ROOM_LIST //방 목록 USER_LIST //방 사람들 목록 RESPONSE_SUCCESS //성공 – 서버 응답으로 사용 RESPONSE_FAIL //실패 – 서버 응답으로 사용 클라이언트 명령 LOGIN은 실행과 동시에 같이 처리됨으로 생략 위의 패킷 타입과 동일 단일명령 끝에 :만 붙여서 처리 LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST: 파라메터명령 : 뒤에 파라메터를 붙여 처리 TALK_MESSAGE:전달할 메시지 ENTER_TO_ROOM:들아걸 방이름 패킷 구조 MessagePacket/PacketHelper 클래스 참조 Header = 로 시작하고 = 로 끝남 key:value로 선언되고, 각 라인은 CRLF 로 처리 length:XXXX 는 Body의 길이, length가 0이면 contents가 없다. Body 문자열로 이루어진 데이터 예시 LOGIN 패킷의 경우 : Body가 없음 = LOGIN length:0 refId:1 refName:nick = USER_LIST 패킷의 경우 [“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다. = USER_LIST length:5 = ["1"] Pipeline 설명 : 클라-&gt;서버-&gt;클라 클라 전송 부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화) Connect ClientConsoleInput 클래스에서 유저 입력을 받음 bootstrap channel의 WriteAndFlushAsync 메소드 호출 MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨 서버 수신 MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성 MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리 그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨 처리된 결과를 클라 전송 4/5 항목과 동일하게 실행하여 전송 서버/클라이언트 콘솔 실행 서버 실행 &gt; ./IMServer 클라 실행 ./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨 &gt; ./IMClient 1 nick &gt; ./IMClient 2 choi]]></summary></entry><entry><title type="html">Dotnetty Prototype Step2</title><link href="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step2" /><published>2023-10-05T00:00:00+09:00</published><updated>2023-10-05T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2%20copy</id><content type="html" xml:base="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html"><![CDATA[<h1 id="채팅-프로그램으로-오델로-게임-구현하기">채팅 프로그램으로 오델로 게임 구현하기</h1>
<ul>
  <li><a href="/dotnetty-server-prototype-step1">채팅 구현</a>의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현</li>
  <li>채팅과 동일하게 서버 한대와 클라이언트 두대로 구성</li>
</ul>

<h2 id="게임-규칙">게임 규칙</h2>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/오델로#규칙">오델로#규칙</a> 참조</li>
  <li>첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현)</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/Othello">github project</a></li>
  <li>프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중</li>
</ul>

<h2 id="구현규칙">구현규칙</h2>
<h3 id="패킷">패킷</h3>
<ul>
  <li>채팅에서 사용한 StringEncoder/StringDecoder를 사용</li>
  <li>포멧
    <ul>
      <li><strong>CommandKey</strong>::<strong>CommandValue</strong></li>
      <li>예) Put::5,4 // 5,4에 돌을 놓아둡니다.</li>
    </ul>
  </li>
</ul>

<h4 id="commandkey">CommandKey</h4>
<h5 id="client--유저가-내릴-수-있는-명령">Client : 유저가 내릴 수 있는 명령</h5>
<ul>
  <li><em>Join</em> : <em>자동 명령</em>, 닉네임 입력하면 자동으로 서버에 등록됩니다.</li>
  <li>Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다.</li>
  <li>Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다.</li>
</ul>

<h5 id="server--서버에서-판단하여-전파하는-명령">Server : 서버에서 판단하여 전파하는 명령</h5>
<ul>
  <li>CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령</li>
  <li>StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령</li>
  <li>TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령</li>
  <li>Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령</li>
  <li>Members : 현재 접속한 구성원들을 알려주는 명령</li>
  <li>FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨</li>
  <li>SuccessPut : Put 명령이 문제없이 실행되었을 때 응답</li>
  <li>FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력</li>
  <li>NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송</li>
</ul>

<h3 id="클라이언트">클라이언트</h3>
<ul>
  <li>소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs</li>
</ul>

<ol>
  <li>클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함</li>
  <li>입력받은 내용을 패킷을 통해 모두 서버로 전송</li>
  <li>즉, 클라이언트에서는 판단하는 로직이 없음</li>
</ol>

<h3 id="서버">서버</h3>
<ul>
  <li>소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs</li>
</ul>

<ol>
  <li>서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한</li>
  <li>각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행</li>
  <li>그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작</li>
</ol>

<h2 id="구현중-발견된-문제점">구현중 발견된 문제점</h2>
<ul>
  <li>패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생
    <ul>
      <li>다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인  <strong>|</strong> 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리
        <ul>
          <li>처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ]
            <ol>
              <li>SuccessPut 처리</li>
              <li>FlipTiles 처리</li>
              <li>NextTurn 처리</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡
    <ul>
      <li>여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용)</li>
    </ul>
  </li>
  <li>클라이언트 콘솔 문제
    <ul>
      <li>오델로 판을 파악하기 어려움</li>
    </ul>
  </li>
</ul>

<h2 id="오델로-서버클라이언트-콘솔화면">오델로 서버/클라이언트 콘솔화면</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-step2-othello.png" alt="서버-클라이언트 오델로 콘솔" /></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><summary type="html"><![CDATA[채팅 프로그램으로 오델로 게임 구현하기 채팅 구현의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현 채팅과 동일하게 서버 한대와 클라이언트 두대로 구성 게임 규칙 오델로#규칙 참조 첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현) 소스코드 github project 프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중 구현규칙 패킷 채팅에서 사용한 StringEncoder/StringDecoder를 사용 포멧 CommandKey::CommandValue 예) Put::5,4 // 5,4에 돌을 놓아둡니다. CommandKey Client : 유저가 내릴 수 있는 명령 Join : 자동 명령, 닉네임 입력하면 자동으로 서버에 등록됩니다. Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다. Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다. Server : 서버에서 판단하여 전파하는 명령 CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령 StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령 TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령 Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령 Members : 현재 접속한 구성원들을 알려주는 명령 FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨 SuccessPut : Put 명령이 문제없이 실행되었을 때 응답 FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력 NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송 클라이언트 소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs 클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함 입력받은 내용을 패킷을 통해 모두 서버로 전송 즉, 클라이언트에서는 판단하는 로직이 없음 서버 소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs 서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한 각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행 그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작 구현중 발견된 문제점 패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생 다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인 | 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리 처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ] SuccessPut 처리 FlipTiles 처리 NextTurn 처리 위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡 여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용) 클라이언트 콘솔 문제 오델로 판을 파악하기 어려움 오델로 서버/클라이언트 콘솔화면]]></summary></entry><entry><title type="html">Unity Prototype Step1</title><link href="http://localhost:4000/unity-prototype-step1" rel="alternate" type="text/html" title="Unity Prototype Step1" /><published>2023-09-27T00:00:00+09:00</published><updated>2023-09-27T00:00:00+09:00</updated><id>http://localhost:4000/15-unity-client-step1</id><content type="html" xml:base="http://localhost:4000/unity-prototype-step1"><![CDATA[<h1 id="1-두-캐릭터를-그리드-안에서-이동하기">1. 두 캐릭터를 그리드 안에서 이동하기</h1>
<ul>
  <li>10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기</li>
  <li>단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step1-movement.png" alt="캐릭터 이동" /></p>

<h2 id="데이터">데이터</h2>
<ul>
  <li>드워프/전사 : 가로,세로 2칸씩 이동(파란색)</li>
  <li>인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색)</li>
</ul>

<h2 id="플로우">플로우</h2>
<ol>
  <li>드워프 선택됨</li>
  <li>해당 드워프의 이동 가능 거리가 표시</li>
  <li>이동가능한 그리드를 선택하면 드워프 이동</li>
  <li>성직자 선택됨</li>
  <li>2,3 동일하게 반복</li>
  <li>1부터 다시 시작</li>
</ol>

<h2 id="데이터구조">데이터구조</h2>
<ul>
  <li>2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것.</li>
  <li>즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서)</li>
</ul>

<h2 id="나중에">나중에…</h2>
<ul>
  <li><a href="/2023/09/25/10-basic-fantasy-pregenerated-characters.html">미리 생성된 캐릭터들</a> 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[1. 두 캐릭터를 그리드 안에서 이동하기 10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기 단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨 데이터 드워프/전사 : 가로,세로 2칸씩 이동(파란색) 인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색) 플로우 드워프 선택됨 해당 드워프의 이동 가능 거리가 표시 이동가능한 그리드를 선택하면 드워프 이동 성직자 선택됨 2,3 동일하게 반복 1부터 다시 시작 데이터구조 2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것. 즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서) 나중에… 미리 생성된 캐릭터들 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획]]></summary></entry><entry><title type="html">Dotnetty Prototype Step1</title><link href="http://localhost:4000/dotnetty-server-prototype-step1" rel="alternate" type="text/html" title="Dotnetty Prototype Step1" /><published>2023-09-27T00:00:00+09:00</published><updated>2023-09-27T00:00:00+09:00</updated><id>http://localhost:4000/16-dotnetty-server-prototype-step1</id><content type="html" xml:base="http://localhost:4000/dotnetty-server-prototype-step1"><![CDATA[<h1 id="세상에서-가장-간단한-채팅-서버클라이언트-구현하기">세상에서 가장 간단한 채팅 서버/클라이언트 구현하기</h1>
<ul>
  <li>참고 문서 : <a href="https://itsallbinary.com/netty-project-understanding-netty-using-simple-real-world-example-of-chat-server-client-good-for-beginners/">Understanding Netty using simple real-world example of Chat server client</a>
    <ul>
      <li>Java 이지만 C#으로 포팅진행합니다.</li>
    </ul>
  </li>
  <li>Bootstrap 이란? : <a href="https://namu.wiki/w/Bootstrap">나무위키 참고</a>
    <ul>
      <li>일반적으로 한 번 시작되면 알아서 진행되는 일련의 과정</li>
    </ul>
  </li>
</ul>

<h2 id="네티-구성요소">네티 구성요소</h2>
<p>간단하고 높은 수준에서 Netty 서버 또는 클라이언트에는 이러한 기본 클래스가 필요합니다.</p>
<ul>
  <li><strong>Program</strong> – 이 클래스는 서버 또는 클라이언트를 부트스트랩합니다. 서버의 경우 지정된 Host/Port에서 서버를 시작합니다. 클라이언트의 경우 제공된 서버에 연결하여 연결을 생성합니다.</li>
  <li><strong>Channel Handler</strong> – 채널 핸들러는 채널 활성, 채널 읽기 또는 예외 발생 등과 같은 다양한 이벤트를 처리합니다.</li>
</ul>

<h2 id="dotnetty를-이용한-채팅-서버-클라이언트-애플리케이션">DotNetty를 이용한 채팅 서버-클라이언트 애플리케이션</h2>
<ol>
  <li>콘솔 입력 기반 채팅 클라이언트 애플리케이션을 만듭니다.</li>
  <li>클라이언트를 시작할 때 우리는 그의 이름을 묻고 그 후에 다른 클라이언트에게 보낼 채팅 메시지를 받습니다.</li>
  <li>채팅 서버에 이름 및 채팅 메시지를 보냅니다.</li>
  <li>그러면 채팅 서버는 보낸 사람의 이름과 함께 해당 메시지를 모든 클라이언트에 게시합니다.</li>
</ol>

<p>다음은 서버와 클라이언트의 구성 요소를 보여주는 다이어그램입니다. 아래 다이어그램은 한 클라이언트에서 다른 클라이언트로의 채팅 메시지 “Hello”의 통신 경로도 추적합니다.
<img src="/assets/images/prototype/prototype-dotnetty-chat-server-client.jpeg" alt="서버-클라이언트 채팅" /></p>

<h2 id="코딩하기">코딩하기</h2>
<ul>
  <li><strong>종속성</strong> – DotNetty 서버 클라이언트 프레임워크를 사용하려면 다음과 같은 package가 필요합니다.
    <ul>
      <li>DotNetty.Common</li>
      <li>DotNetty.Codecs</li>
      <li>DotNetty.Handlers</li>
      <li>DotNetty.Transport</li>
    </ul>
  </li>
</ul>

<h2 id="bootstrapping-네티">Bootstrapping 네티</h2>
<ul>
  <li><strong>ServerBootstrap</strong> – 서버 채널을 부트스트랩하고 서버를 시작하는 코드입니다. 연결을 수신할 포트에 서버를 바인딩합니다.</li>
  <li><strong>Bootstrap</strong> – 클라이언트 채널을 부트스트랩하는 코드입니다.</li>
  <li><strong>EventLoopGroup</strong>
    <ul>
      <li>EventLoop들의 그룹입니다. EventLoop는 등록된 채널에 대한 모든 I/O 작업을 처리합니다.</li>
      <li>ServerBootstrap에는 두 가지 유형의 EventLoopGroup, 즉 “boss”와 “worker”가 필요합니다. 클라이언트 boostrap에는 보스 그룹이 필요하지 않습니다.</li>
      <li>Boss EventLoopGroup – 이 EventLoop 그룹은 들어오는 연결(connection)을 수락(accept)하고 등록(register)합니다.</li>
      <li>Worker EventLoopGroup – Boss가 연결을 수락하고 이를 Worker EventLoopGroup에 등록합니다. Worker는 해당 연결을 통해 통신하는 동안 모든 이벤트를 처리합니다.</li>
    </ul>
  </li>
  <li>채널 <strong>TcpServerSocketChannel</strong> – Tcp Socket을 이용하여 새 연결을 허용하도록 서버를 구성합니다. 클라이언트의 경우 TcpSocketChannel을 이용합니다.</li>
  <li><strong>Decoder/Encoder(StringDecoder / StringEncoder)</strong>
    <ul>
      <li>Netty 통신은 Byte 형식의 네트워크 소켓 채널을 통해 발생합니다. 따라서 특정 데이터형을 전송하려는 경우 데이터형을 Byte로 인코딩하는 인코더와 Byte를 데이터형로 디코딩하는 인코더를 제공합니다.</li>
      <li>StringDecoder, StringEncoder는 Netty에서 제공됩니다. 하지만 필요한 모든 데이터 유형에 대해 자체 인코더나 디코더를 만들 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples">github project</a></li>
</ul>

<h2 id="테스트-콘솔화면">테스트 콘솔화면</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-chat-server-client-sample.png" alt="서버-클라이언트 콘솔" /></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><summary type="html"><![CDATA[세상에서 가장 간단한 채팅 서버/클라이언트 구현하기 참고 문서 : Understanding Netty using simple real-world example of Chat server client Java 이지만 C#으로 포팅진행합니다. Bootstrap 이란? : 나무위키 참고 일반적으로 한 번 시작되면 알아서 진행되는 일련의 과정 네티 구성요소 간단하고 높은 수준에서 Netty 서버 또는 클라이언트에는 이러한 기본 클래스가 필요합니다. Program – 이 클래스는 서버 또는 클라이언트를 부트스트랩합니다. 서버의 경우 지정된 Host/Port에서 서버를 시작합니다. 클라이언트의 경우 제공된 서버에 연결하여 연결을 생성합니다. Channel Handler – 채널 핸들러는 채널 활성, 채널 읽기 또는 예외 발생 등과 같은 다양한 이벤트를 처리합니다. DotNetty를 이용한 채팅 서버-클라이언트 애플리케이션 콘솔 입력 기반 채팅 클라이언트 애플리케이션을 만듭니다. 클라이언트를 시작할 때 우리는 그의 이름을 묻고 그 후에 다른 클라이언트에게 보낼 채팅 메시지를 받습니다. 채팅 서버에 이름 및 채팅 메시지를 보냅니다. 그러면 채팅 서버는 보낸 사람의 이름과 함께 해당 메시지를 모든 클라이언트에 게시합니다. 다음은 서버와 클라이언트의 구성 요소를 보여주는 다이어그램입니다. 아래 다이어그램은 한 클라이언트에서 다른 클라이언트로의 채팅 메시지 “Hello”의 통신 경로도 추적합니다. 코딩하기 종속성 – DotNetty 서버 클라이언트 프레임워크를 사용하려면 다음과 같은 package가 필요합니다. DotNetty.Common DotNetty.Codecs DotNetty.Handlers DotNetty.Transport Bootstrapping 네티 ServerBootstrap – 서버 채널을 부트스트랩하고 서버를 시작하는 코드입니다. 연결을 수신할 포트에 서버를 바인딩합니다. Bootstrap – 클라이언트 채널을 부트스트랩하는 코드입니다. EventLoopGroup EventLoop들의 그룹입니다. EventLoop는 등록된 채널에 대한 모든 I/O 작업을 처리합니다. ServerBootstrap에는 두 가지 유형의 EventLoopGroup, 즉 “boss”와 “worker”가 필요합니다. 클라이언트 boostrap에는 보스 그룹이 필요하지 않습니다. Boss EventLoopGroup – 이 EventLoop 그룹은 들어오는 연결(connection)을 수락(accept)하고 등록(register)합니다. Worker EventLoopGroup – Boss가 연결을 수락하고 이를 Worker EventLoopGroup에 등록합니다. Worker는 해당 연결을 통해 통신하는 동안 모든 이벤트를 처리합니다. 채널 TcpServerSocketChannel – Tcp Socket을 이용하여 새 연결을 허용하도록 서버를 구성합니다. 클라이언트의 경우 TcpSocketChannel을 이용합니다. Decoder/Encoder(StringDecoder / StringEncoder) Netty 통신은 Byte 형식의 네트워크 소켓 채널을 통해 발생합니다. 따라서 특정 데이터형을 전송하려는 경우 데이터형을 Byte로 인코딩하는 인코더와 Byte를 데이터형로 디코딩하는 인코더를 제공합니다. StringDecoder, StringEncoder는 Netty에서 제공됩니다. 하지만 필요한 모든 데이터 유형에 대해 자체 인코더나 디코더를 만들 수 있습니다. 소스코드 github project 테스트 콘솔화면]]></summary></entry><entry><title type="html">Basic Fantasy - 미리 생성된 캐릭터들</title><link href="http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters.html" rel="alternate" type="text/html" title="Basic Fantasy - 미리 생성된 캐릭터들" /><published>2023-09-25T00:00:00+09:00</published><updated>2023-09-25T00:00:00+09:00</updated><id>http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters</id><content type="html" xml:base="http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters.html"><![CDATA[<ul>
  <li>미리 생성된 캐릭터 데이터 시트</li>
</ul>

<p><a href="/assets/files/characters.xlsx">캐릭터 데이터 데이터</a></p>]]></content><author><name>nickchoi</name></author><category term="BasicFantasy" /><category term="Rule" /><category term="참고자료" /><summary type="html"><![CDATA[미리 생성된 캐릭터 데이터 시트 캐릭터 데이터 데이터]]></summary></entry><entry><title type="html">Basic Fantasy - 전투 치트 시트</title><link href="http://localhost:4000/2023/09/24/22-basic-fantasy-combat-cheat-sheet.html" rel="alternate" type="text/html" title="Basic Fantasy - 전투 치트 시트" /><published>2023-09-24T00:00:00+09:00</published><updated>2023-09-24T00:00:00+09:00</updated><id>http://localhost:4000/2023/09/24/22-basic-fantasy-combat-cheat-sheet</id><content type="html" xml:base="http://localhost:4000/2023/09/24/22-basic-fantasy-combat-cheat-sheet.html"><![CDATA[<h1 id="조우와-전투">조우와 전투</h1>
<h2 id="조우">조우</h2>
<ol>
  <li>10초 라운드 진행</li>
  <li>놀람 굴림
    <ul>
      <li>d6 - 1,2에 놀람(엘프는 1일 때)</li>
    </ul>
  </li>
  <li>NPC 반응 굴림</li>
</ol>

<h2 id="전투">전투</h2>
<ol>
  <li>주도권 굴림(각 라운드 시작시)
    <ul>
      <li>d6 +/- DEX 수정치</li>
    </ul>
  </li>
  <li>주도권 순서에 따라 행동. 가장 높은 값이 먼저
    <ol>
      <li>캐릭터/NPC는 때리거나, 쏘거나, 이동하고 마법 캐스트할 수 있습니다.</li>
      <li>이동 : 라운드당 40피트 이동할 수 있습니다(수정치가 있을 수 있습니다.)</li>
    </ol>
  </li>
  <li>때리거나 쏠 경우, 명중 굴림
    <ol>
      <li>d20 + 공격 보너스 + STR/DEX 보너스 (근거리, 원거리) (1)(2)</li>
      <li>상대편 AC와 비교하여 같거나 크면 명중 성공</li>
      <li>피해굴림 : 무기 피해 + STR 보너스 (1)</li>
    </ol>
  </li>
</ol>

<h2 id="사기">사기</h2>
<ol>
  <li>조우시 NPC 그룹이 HP가 50%까지 줄었거나, 단일 상대편의 HP가 50%까지 줄었을 때 사기 굴림
    <ul>
      <li>2d6 VS 사기 점수</li>
    </ul>
  </li>
</ol>

<h2 id="경험치">경험치</h2>
<ol>
  <li>경험치 포인트(EP)는 패배한 적들로부터 얻는데, 상대편의 HD 혹은 레벨에 따라 양이 결정</li>
</ol>

<p>(1) 다른 보너스를 더함; 예를 들어 공격자가 마법 무기를 가져을 경우
(2) 순수 20은 항상 명중이며, 순수 1은 항상 실패</p>

<h2 id="액션에-대한-보너스">액션에 대한 보너스</h2>
<ul>
  <li>돌격
    <ul>
      <li>10피트의 명확한 시야와 창 또는 창 필요: 명중 +2, AC -2</li>
    </ul>
  </li>
  <li>방어 이동
    <ul>
      <li>사용하면 1/2 비율로 이동할 수 있습니다. 전속력 이동 &amp; 분리 공격 +2</li>
    </ul>
  </li>
  <li>뒤에서 공격
    <ul>
      <li>적중 +2, 대상은 방패 보너스를 얻지 못합니다</li>
    </ul>
  </li>
  <li>접근전
    <ul>
      <li>명중 굴림 및 피해에 STR 수정치를 추가</li>
    </ul>
  </li>
  <li>미사일 공격
    <ul>
      <li>명중 굴림에 DEX 수정치를 추가하고, 데미지에 STR 수정치 추가</li>
    </ul>
  </li>
  <li>미사일 대 인접 적
    <ul>
      <li>명중굴림 -5</li>
    </ul>
  </li>
  <li>빗나간 미사일
    <ul>
      <li>대상에 인접한 아군 캐릭터를 공격할 수 있음</li>
    </ul>
  </li>
  <li>피해 억제
    <ul>
      <li>명중 시 -4; 대상이 0으로 감소하고 의식을 잃었지만 죽지 않으면 HP가 1 남습니다.</li>
    </ul>
  </li>
  <li>난투
    <ul>
      <li>펀치로 1d3의 피해를 억제합니다. 발차기에 1d4 -2 명중굴림</li>
    </ul>
  </li>
  <li>에너지 고갈
    <ul>
      <li>음수 레벨, hp 상당의 HD 1 손실, 공격 및 내성 굴림에 -1</li>
    </ul>
  </li>
  <li>건강 손실
    <ul>
      <li>정상적인 휴식으로 하루에 1포인트 회복, 최종 포인트에 대한 죽음의 광선 내성 굴림</li>
      <li>건강 수정치가 변경되면 적절하게 HP를 잃거나 얻습니다.</li>
    </ul>
  </li>
  <li>실청
    <ul>
      <li>1d6에서 1-3에 놀라고, 우선권 굴림에 -1</li>
    </ul>
  </li>
  <li>실명
    <ul>
      <li>1d6에서 1-4에 놀라고, 공격 굴림과 AC에 -4, 우선권 굴림에 -2</li>
    </ul>
  </li>
</ul>]]></content><author><name>nickchoi</name></author><category term="BasicFantasy" /><category term="Rule" /><category term="참고자료" /><summary type="html"><![CDATA[조우와 전투 조우 10초 라운드 진행 놀람 굴림 d6 - 1,2에 놀람(엘프는 1일 때) NPC 반응 굴림 전투 주도권 굴림(각 라운드 시작시) d6 +/- DEX 수정치 주도권 순서에 따라 행동. 가장 높은 값이 먼저 캐릭터/NPC는 때리거나, 쏘거나, 이동하고 마법 캐스트할 수 있습니다. 이동 : 라운드당 40피트 이동할 수 있습니다(수정치가 있을 수 있습니다.) 때리거나 쏠 경우, 명중 굴림 d20 + 공격 보너스 + STR/DEX 보너스 (근거리, 원거리) (1)(2) 상대편 AC와 비교하여 같거나 크면 명중 성공 피해굴림 : 무기 피해 + STR 보너스 (1) 사기 조우시 NPC 그룹이 HP가 50%까지 줄었거나, 단일 상대편의 HP가 50%까지 줄었을 때 사기 굴림 2d6 VS 사기 점수 경험치 경험치 포인트(EP)는 패배한 적들로부터 얻는데, 상대편의 HD 혹은 레벨에 따라 양이 결정 (1) 다른 보너스를 더함; 예를 들어 공격자가 마법 무기를 가져을 경우 (2) 순수 20은 항상 명중이며, 순수 1은 항상 실패 액션에 대한 보너스 돌격 10피트의 명확한 시야와 창 또는 창 필요: 명중 +2, AC -2 방어 이동 사용하면 1/2 비율로 이동할 수 있습니다. 전속력 이동 &amp; 분리 공격 +2 뒤에서 공격 적중 +2, 대상은 방패 보너스를 얻지 못합니다 접근전 명중 굴림 및 피해에 STR 수정치를 추가 미사일 공격 명중 굴림에 DEX 수정치를 추가하고, 데미지에 STR 수정치 추가 미사일 대 인접 적 명중굴림 -5 빗나간 미사일 대상에 인접한 아군 캐릭터를 공격할 수 있음 피해 억제 명중 시 -4; 대상이 0으로 감소하고 의식을 잃었지만 죽지 않으면 HP가 1 남습니다. 난투 펀치로 1d3의 피해를 억제합니다. 발차기에 1d4 -2 명중굴림 에너지 고갈 음수 레벨, hp 상당의 HD 1 손실, 공격 및 내성 굴림에 -1 건강 손실 정상적인 휴식으로 하루에 1포인트 회복, 최종 포인트에 대한 죽음의 광선 내성 굴림 건강 수정치가 변경되면 적절하게 HP를 잃거나 얻습니다. 실청 1d6에서 1-3에 놀라고, 우선권 굴림에 -1 실명 1d6에서 1-4에 놀라고, 공격 굴림과 AC에 -4, 우선권 굴림에 -2]]></summary></entry><entry><title type="html">Basic Fantasy - 평면도를 이용한 전투</title><link href="http://localhost:4000/2023/09/22/23-basic-fantasy-combat-with-floor.html" rel="alternate" type="text/html" title="Basic Fantasy - 평면도를 이용한 전투" /><published>2023-09-22T00:00:00+09:00</published><updated>2023-09-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/09/22/23-basic-fantasy-combat-with-floor</id><content type="html" xml:base="http://localhost:4000/2023/09/22/23-basic-fantasy-combat-with-floor.html"><![CDATA[<h1 id="평면도를-이용한-전투">평면도를 이용한 전투</h1>
<h2 id="소개">소개</h2>

<p><strong>Basic Fantasy RPG</strong>는 평면도 및 미니어처와 함께 사용하도록 특별히 설계되지 않았지만 많은 플레이어가 게임에서 이러한 도구를 사용합니다. 특히 평면도는 전투를 시각화하는 데 유용한 도움이 될 수 있습니다. 그들은 또한 약간 더 전술적인 플레이 스타일을 장려하는 경향이 있습니다. 또한 Roll20 및 MapTool과 같은 가상 테이블탑 소프트웨어의 가용성이 증가함에 따라 평면도를 작업에 통합하는 것이 그 어느 때보다 쉬워졌습니다.</p>

<p>이 보충 자료의 목적은 평면도와 미니어처를 사용하여 Basic Fantasy RPG에서 전투를 해결하기 위한 일관된 규칙 세트를 제공하는 것입니다. 이러한 지침은 일반적으로 Basic Fantasy RPG 핵심 규칙에 설명된 규칙을 따릅니다. 그러나 일관된 플레이를 달성하기 위해 핵심 규칙에 약간의 수정과 확장이 불가피하게 있습니다.</p>

<p>다른 보충 자료와 마찬가지로 이 문서도 자신이 선호하는 플레이 스타일에 따라 맞춤 설정할 수 있는 하우스 룰 세트로 취급하세요.</p>

<h2 id="평면도">평면도</h2>

<ul>
  <li>정사각형 격자를 사용하십시오.</li>
  <li>각 정사각형은 5피트 x 5피트 면적을 나타냅니다.</li>
  <li>중소형 전투원(예: 인간 크기까지)은 각각 한 칸씩 차지합니다. 대규모 전투원은 일반적으로 한 칸 이상을 차지합니다. 이에 대해서는 <strong>특수 상황 섹션</strong>에서 설명합니다.</li>
</ul>

<p><img src="/assets/images/basic-fantasy/the-floor-plan-size.png" alt="평면도 사이즈" /></p>

<ul>
  <li>
    <p>일반적으로 한 칸에 한 명 이상의 전투원이 점유할 수 없습니다. 여기에는 몇 가지 예외가 있습니다.  전투원은 사망하거나 의식이 없거나 기타 무능력하고 엎드린 전투원과 같은 칸에 들어갈 수도 있습니다. 또한 이동 섹션에 설명된 대로 전투원은 아군이 점령한 사각형을 통해 이동할 수 있습니다.</p>
  </li>
  <li>
    <p>각 전투원은 또한 연관된 방향, 즉 그들이 바라보는 방향을 가지고 있습니다. 이것은 바로 인접한 4개의 사각형 중 하나를 향할 수 있습니다. 뒤에서 공격 등의 측면을 해결하려면 페이싱이 중요합니다.</p>
  </li>
</ul>

<h2 id="이동">이동</h2>

<ul>
  <li>
    <p>주어진 라운드에서 각 전투원은 이동 속도까지 거리를 걸은 다음 공격할 수 있습니다.</p>
  </li>
  <li>
    <p>대신 전투원은 이동 속도의 최대 두 배까지 거리를 달릴 수 있습니다. 이 경우 해당 라운드 동안 공격을 받을 수 없습니다.</p>
  </li>
  <li>
    <p>수평 또는 수직 방향의 각 이동 사각형은 전투원의 총 이동 허용량의 5 피트를 소비합니다. 대각선 이동 비용은 5 피트와 10 피트 사이에서 번갈아 나타납니다. 즉, 대각선으로 1개의 정사각형은 5 피트, 2개의 정사각형은 15 피트, 3개의 정사각형은 20 피트, 4개의 정사각형은 30 피트 등입니다.</p>
  </li>
  <li>
    <p>GM은 장애물이나 어려운 지형을 고려하여 추가 이동 비용을 적용할 수 있습니다. 예를 들어, GM은 테이블, 벤치 또는 상대적으로 낮은 벽과 같은 작은 장벽을 건너는 데 5 피트의 추가 이동 비용이 든다고 결정할 수 있습니다. 또는 GM은 가파른 계단을 오르거나 물을 헤쳐나갈 때 전투원이 정상 속도의 절반으로만 움직일 수 있다고 규정할 수도 있습니다. 이는 전적으로 선택 사항이며 GM의 재량에 따릅니다.</p>
  </li>
  <li>
    <p>전투원은 아군이 점령한 사각형을 방해받지 않고 이동합니다. 그러나 여전히 적용될 수 있는 다른 이동 제한이 적용됩니다.</p>
  </li>
  <li>
    <p>전투원이 상대방과 인접한 사각형(수평, 수직 또는 대각선)에 들어가자마자 근접전을 벌이는 것으로 간주됩니다. 이는 즉시 이동 제한을 적용됩니다(<strong>근접 전투</strong> 섹션 참조).</p>
  </li>
  <li>
    <p>해결해야 할 더 문제가 되는 이동 유형 중 하나는 두 전투원이 동일한 주도권으로 행동할 때의 동시 이동입니다. 이에 대해서는 <strong>특수 상황</strong> 섹션에서 설명합니다.</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">갑옷 / 침구류</th>
      <th style="text-align: center">라운드당  이동비율</th>
      <th style="text-align: center">평면도 이동 예제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">갑옷없음 / 마법가죽</td>
      <td style="text-align: center">40 피트</td>
      <td style="text-align: center">가로/세로 8칸, 대각선으로 5칸까지 걸어간 후 공격가능하고, 가로/세로 최대 16개의 사각형 또는 대각선으로 11개의 사각형까지 달릴 수 있습니다 \</td>
    </tr>
    <tr>
      <td style="text-align: center">가벼운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">갑옷없음 / 마법가죽</td>
      <td style="text-align: center">30 피트</td>
      <td style="text-align: center">가로/세로 6칸, 대각선으로 4칸까지 걸어간 후 공격가능하고, 가로/세로 최대 16개의 사각형 또는 대각선으로 8개의 사각형까지 달릴 수 있습니다 \</td>
    </tr>
    <tr>
      <td style="text-align: center">무거운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">가죽갑옷 / 마법금속</td>
      <td style="text-align: center">^^</td>
      <td style="text-align: center">^^ \</td>
    </tr>
    <tr>
      <td style="text-align: center">가벼운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">가죽갑옷 / 마법금속</td>
      <td style="text-align: center">20 피트</td>
      <td style="text-align: center">가로/세로 4칸, 대각선으로 3칸까지 걸어간 후 공격가능하고, 가로/세로 최대 8개의 사각형 또는 대각선으로 5개의 사각형까지 달릴 수 있습니다 \</td>
    </tr>
    <tr>
      <td style="text-align: center">무거운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">금속갑옷</td>
      <td style="text-align: center">^^</td>
      <td style="text-align: center">^^ \</td>
    </tr>
    <tr>
      <td style="text-align: center">가벼운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">금속갑옷</td>
      <td style="text-align: center">10 피트</td>
      <td style="text-align: center">가로/세로 2칸, 대각선으로 1칸까지 걸어간 후 공격가능하고, 가로/세로 최대 4개의 사각형 또는 대각선으로 3개의 사각형까지 달릴 수 있습니다 \</td>
    </tr>
    <tr>
      <td style="text-align: center">무거운 무게 ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h3 id="이동-예제">이동 예제</h3>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-movement-example.png" alt="이동 예제" /></p>

<p>Tannen(이동 속도 20 피트)은 근접전에서 오우거와 교전하기 위해 앞으로 걸어갑니다. 그는 이번 라운드를 그의 검으로 공격할 수 있습니다. Doughbert(이동 속도 30 피트)는 대각선으로 걸어갑시다. 그는 숏보우로 이번 라운드를 공격할 수 있습니다. Mandross(이동 속도 40 피트)는 수평/수직 및 대각선 섞어서 이동합니다. 그는 이번 라운드에도 공격할 수 있습니다. Paladin(이동 속도 30 피트)가 도망갑니다. 그는 평소 이동 속도의 두 배까지 거리(예: 60피트)를 이동할 수 있지만 이번 라운드에는 공격할 수 없습니다.</p>

<h2 id="미사일-발사">미사일 발사</h2>

<ul>
  <li>전투원이 미사일 공격을 수행하려면 두 가지 조건이 충족되어야 합니다.
    <ul>
      <li>상대는 사용 중인 미사일 무기의 범위 내에 있어야 합니다.</li>
      <li>전투원은 상대방을 볼 수 있는 시야가 있어야 합니다. 전투원이 장애물을 통과하지 않고 자신의 사각형에 있는 한 지점에서 상대방의 사각형까지 직선을 그릴 수 있으면 시야가 확보됩니다.</li>
    </ul>
  </li>
  <li>
    <p>그러나 전투원이 완전히 명확한 시야를 확보하지 못하더라도 GM은 장애물의 성격과 그것이 제공하는 엄폐 정도에 따라 미사일 공격을 허용할 수 있습니다. <strong>Basic Fantasy RPG 핵심 규칙의 조우 섹션</strong>에 있는 <strong>은폐 및 은폐</strong> 규칙을 따르세요.</p>
  </li>
  <li>아군이 점령한 사각형을 통한 미사일 발사는 GM의 재량에 따라 허용됩니다. 이러한 상황에서 GM은 아군의 존재로 인해 사격이 더 어려워진다고 판단되면(엄폐 및 은폐 규칙과 유사한 방식으로) “명중” 굴림에 페널티를 적용하기로 결정할 수 있습니다.</li>
</ul>

<h3 id="미사일-발사-예제">미사일 발사 예제</h3>
<h4 id="예제-1">예제 1</h4>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-missile-fire-example1.png" alt="미사일 발사 예제1" /></p>

<p>Paladin은 Goblin 1에게 발사할 수 없습니다. 그는 시야가 없습니다. Paladin은 Goblin 2에 대한 명확한 시야를 갖고 있으며 정상적으로 발사할 수 있습니다. Goblin 3에는 부분 엄폐 기능이 있습니다. GM의 재량에 따라 Paladin은 적절한 페널티를 주어 발사할 수 있습니다.</p>

<h4 id="예제-2">예제 2</h4>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-missile-fire-example2.png" alt="미사일 발사 예제2" /></p>

<p>예제 1과 상황은 동일하지만 MapTool의 “전장 안개” 기능이 활성화되었습니다. 검은색으로 표시된 부분은 덮개로 인해 Paladin이 볼 수 없는 부분입니다. 이는 시선을 결정하는 데 유용한 기능이 될 수 있습니다.</p>

<h2 id="근접전투">근접전투</h2>

<ul>
  <li>
    <p>두 명의 상대 전투원이 서로 인접하게 되면(수평, 수직 또는 대각선으로) 근접전을 벌이는 것으로 간주됩니다. 이는 즉시 이동 제한을 적용됩니다.</p>
  </li>
  <li>공격할 차례가 되면 근접 전투원은 다음을 수행할 수 있습니다(이 순서대로).
    <ol>
      <li><em>상대방과의 근접전에서 벗어나지 않는 한 정상 이동 속도의 절반까지 이동합니다.</em> 상대방은 전투원을 알고 있는 경우 이 움직임을 추적하기 위해 방향을 자유롭게 변경할 수 있습니다. 전투원이 상대방과의 근접전에서 벗어나고 싶다면 아래의 <strong>전투 철수 및 도주에 대한 규칙</strong>을 참조하세요.</li>
      <li>방향을 한 번 변경합니다(즉, 특정 방향을 향하도록 회전).</li>
      <li>앞이나 옆에 있는 5개의 사각형 중 하나에 있는 상대를 공격합니다. 전투원은 자신 뒤에 있는 세 칸 중 하나에 있는 상대를 공격할 수 없습니다.</li>
    </ol>
  </li>
  <li>
    <p>전투원이 근접전에서 벗어나기를 원하는 경우 전투 철수 또는 도주라는 두 가지 옵션이 있습니다. 후자만이 전투원을 <strong>분리 사격</strong>의 위험에 빠뜨립니다(아래 참조).</p>
  </li>
  <li>
    <p>전투 철수시 전투원이 정상 이동 속도의 최대 절반까지 근접 공격에서 물러날 수 있습니다. 전투원은 전투 철수를 수행한 후에도 범위 내에 상대가 있는 경우 정상적으로 공격할 수 있습니다.</p>
  </li>
  <li>전투원이 전투 철수(예: 일반적인 걷기 또는 달리기 속도)를 수행하지 않고 상대와 인접한 사각형에서 단순히 이동하는 경우 이는 도주로 분류되며 전투원은 분리 사격에 노출됩니다. 이를 통해 상대는 Basic Fantasy RPG 핵심 규칙의 조우 섹션에 있는 <strong>방어 이동 규칙</strong>에 따라 +2 명중굴림으로 즉시 공격을 할 수 있습니다. 이 분리 사격은 전투원이 특정 라운드에서 이미 수행했거나 아직 수행하지 않은 모든 행동에 추가됩니다. 전투원은 주어진 라운드에서 주어진 상대에 대해 단 한 번의 분리 사격을 할 수 있습니다.</li>
</ul>

<h3 id="근접-예제">근접 예제</h3>
<h4 id="예제-1-1">예제 1</h4>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-melee-example1.png" alt="근접 예제1" /></p>

<p>Tannen(이동 속도 20피트)이 Goblin과 근접전을 벌이고 있습니다. 그는 녹색 사각형(10 피트, 이동 속도의 절반) 중 하나로 이동할 수 있으며 방향을 한 번 변경한 다음 공격할 수 있습니다. 이 경우 Goblin은 Tannen의 움직임을 추적하기 위해 방향을 조정할 수도 있습니다. 또는 Tannen은 전투에서 철수하고(이동 속도의 절반인 10 피트) 주황색 사각형 중 하나로 이동할 수 있습니다. 그가 빨간색 사각형 중 하나로 이동하면(20 피트, 그의 최대 이동 속도 또는 그가 달리고 있는 경우 더 빠른 속도) 그는 도망가게 되며 Goblin의 <strong>분리 사격</strong>을 받게 됩니다.</p>

<h4 id="예제-2-1">예제 2</h4>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-melee-example2.png" alt="근접 예제2" /></p>

<p>Doughbert(이동 30 피트)는 Goblin을 지나 서쪽으로 이동하려고 합니다. 그는 5 피트 또는 10 피트를 사각형 1과 2로 이동한 다음 원할 경우 미사일 공격을 가할 수 있습니다. 또는 그는 15 피트 또는 25 피트를 사각형 3 또는 4로 이동하여 고블린에게 근접 공격을 할 수 있습니다. (3번 사각형에서 4번 사각형으로의 근접전 이동이 4번 사각형으로 이동하는 데 25피트가 필요합니다.) 일반 속도의 절반, 즉 한 칸을 이동하는 데 10 피트의 비용이 듭니다). 5번 칸에 도달하려면 35피트의 이동 비용이 필요합니다. 이는 그가 달려야 한다는 것을 의미하므로 이번 라운드에는 근접 공격을 할 수 없습니다. 만약 그가 6칸 이상으로 달려간다면, 그는 근접전에서 나가게 되고 분리 사격을 받게 될 것입니다.</p>

<h2 id="특별한-상황">특별한 상황</h2>
<h3 id="뒤에서-공격하기">뒤에서 공격하기</h3>

<ul>
  <li>
    <p><strong>뒤에서 공격하기</strong>는 사각형 중 하나에서 전투원의 후방으로 수행되는 공격입니다. 소형 또는 중형 전투원은 근접 목적을 위한 세 개의 사각형을 가지고 있습니다(분명히 미사일 공격용으로 더 그렇습니다). 더 큰 전투원은 더 많은 수의 후방 사각형을 갖게 됩니다.</p>
  </li>
  <li>
    <p>후방 공격에는 두 가지 유형이 있습니다. 일반 전투에서 발생하는 공격과 도둑의 특수 <strong>기습 공격</strong>입니다.</p>
  </li>
  <li>
    <p>일반적인 전투의 경우 상대 뒤에서 공격하는 경우 일반적으로 Basic Fantasy RPG 핵심 규칙의 조우 섹션에 설명된 대로 +2 공격 보너스를 받습니다.</p>
  </li>
  <li>
    <p>일반적으로 방어자가 자신의 상대를 모두 알고 있는 경우 공격자 중 한 명이 뒤에서 공격을 수행할 수 있는 상황을 활용하려면 최소한 세 명의 공격자가 필요합니다. 공격자의 수가 적다면 방어자는 항상 후방에 상대가 없도록 방향을 조정할 수 있습니다.</p>
  </li>
  <li>
    <p>어떤 이유로든 방어자가 자신의 상대 중 한 명을 인식하지 못하는 경우(예: 투명화 또는 일종의 산만함을 통해) GM은 3명 미만의 공격자로 뒤에서 공격이 가능하다고 판단할 수 있습니다. 도둑의 몰래 공격(Basic Fantasy RPG 핵심 규칙의 <strong>캐릭터 섹션</strong>)에도 동일한 원칙이 적용됩니다. 일반적으로 말하자면, 주어진 전투에서 동일한 상대에게 그러한 공격은 단 한 번만 수행될 수 있습니다.</p>
  </li>
</ul>

<h4 id="뒤에서-공격하기-예제">뒤에서 공격하기 예제</h4>
<p><img src="/assets/images/basic-fantasy/the-floor-plan-attack-from-behind-example1.png" alt="뒤에서 공격 예제1" />
<img src="/assets/images/basic-fantasy/the-floor-plan-attack-from-behind-example2.png" alt="뒤에서 공격 예제2" /></p>

<p>현재 방향을 기준으로 Goblin의 후면 사각형은 빨간색으로 표시됩니다. 두 명의 공격자(왼쪽)만 있으면 Goblin이 공격자 중 누구도 뒤에 있지 않도록 방향을 조정할 수 있습니다(고블린이 이러한 공격자를 알고 있다고 가정). 그러나 3명의 공격자(오른쪽)가 있는 경우 고블린은 뒤에서 적어도 한 번의 공격을 받을 수 있습니다(이 경우 Doughbert가 운이 좋은 친구입니다).</p>

<h2 id="동시-이동">동시 이동</h2>

<ul>
  <li>
    <p>동시 이동, 즉 두 명 이상의 전투원이 동일한 주도권 점수로 행동하는 경우 평면도를 사용하여 해결하는 것이 다소 문제가 될 수 있습니다.</p>
  </li>
  <li>
    <p>최신판에서 채택한 한 가지 접근 방식은 두 전투원이 동시에 행동할 가능성을 완전히 제거하는 것입니다. 더 큰 주도권 주사위(예: d20)는 동시 행동이 발생할 확률을 줄입니다. 각 전투원이 전투 순서에서 고유한 위치를 갖도록 추가 타이 브레이커(예: 가장 높은 민첩성 또는 추가 타이 브레이크 롤)를 사용할 수 있습니다. 그러한 접근 방식은 규칙 세트에 더 큰 영향을 미친다는 점을 명심하십시오. 예를 들어 주문 중단(Basic Fantasy RPG 핵심 규칙의 주문 섹션)은 동시 작업에 의존하는 한 측면입니다.</p>
  </li>
  <li>
    <p>대안적인 접근 방식은 동일한 선제 점수로 행동하는 모든 전투원이 이동 점수가 가장 높은 전투원부터 시작하여 한 번에 5피트씩 교대로 이동할 수 있도록 하는 것입니다. 주어진 전투원의 움직임이 떨어지면 그들은 멈춥니다. 다른 사람들도 움직임이 없어질 때까지 계속 움직입니다.</p>
  </li>
</ul>]]></content><author><name>nickchoi</name></author><category term="BasicFantasy" /><category term="Rule" /><category term="참고자료" /><summary type="html"><![CDATA[평면도를 이용한 전투 소개 Basic Fantasy RPG는 평면도 및 미니어처와 함께 사용하도록 특별히 설계되지 않았지만 많은 플레이어가 게임에서 이러한 도구를 사용합니다. 특히 평면도는 전투를 시각화하는 데 유용한 도움이 될 수 있습니다. 그들은 또한 약간 더 전술적인 플레이 스타일을 장려하는 경향이 있습니다. 또한 Roll20 및 MapTool과 같은 가상 테이블탑 소프트웨어의 가용성이 증가함에 따라 평면도를 작업에 통합하는 것이 그 어느 때보다 쉬워졌습니다. 이 보충 자료의 목적은 평면도와 미니어처를 사용하여 Basic Fantasy RPG에서 전투를 해결하기 위한 일관된 규칙 세트를 제공하는 것입니다. 이러한 지침은 일반적으로 Basic Fantasy RPG 핵심 규칙에 설명된 규칙을 따릅니다. 그러나 일관된 플레이를 달성하기 위해 핵심 규칙에 약간의 수정과 확장이 불가피하게 있습니다. 다른 보충 자료와 마찬가지로 이 문서도 자신이 선호하는 플레이 스타일에 따라 맞춤 설정할 수 있는 하우스 룰 세트로 취급하세요. 평면도 정사각형 격자를 사용하십시오. 각 정사각형은 5피트 x 5피트 면적을 나타냅니다. 중소형 전투원(예: 인간 크기까지)은 각각 한 칸씩 차지합니다. 대규모 전투원은 일반적으로 한 칸 이상을 차지합니다. 이에 대해서는 특수 상황 섹션에서 설명합니다. 일반적으로 한 칸에 한 명 이상의 전투원이 점유할 수 없습니다. 여기에는 몇 가지 예외가 있습니다. 전투원은 사망하거나 의식이 없거나 기타 무능력하고 엎드린 전투원과 같은 칸에 들어갈 수도 있습니다. 또한 이동 섹션에 설명된 대로 전투원은 아군이 점령한 사각형을 통해 이동할 수 있습니다. 각 전투원은 또한 연관된 방향, 즉 그들이 바라보는 방향을 가지고 있습니다. 이것은 바로 인접한 4개의 사각형 중 하나를 향할 수 있습니다. 뒤에서 공격 등의 측면을 해결하려면 페이싱이 중요합니다. 이동 주어진 라운드에서 각 전투원은 이동 속도까지 거리를 걸은 다음 공격할 수 있습니다. 대신 전투원은 이동 속도의 최대 두 배까지 거리를 달릴 수 있습니다. 이 경우 해당 라운드 동안 공격을 받을 수 없습니다. 수평 또는 수직 방향의 각 이동 사각형은 전투원의 총 이동 허용량의 5 피트를 소비합니다. 대각선 이동 비용은 5 피트와 10 피트 사이에서 번갈아 나타납니다. 즉, 대각선으로 1개의 정사각형은 5 피트, 2개의 정사각형은 15 피트, 3개의 정사각형은 20 피트, 4개의 정사각형은 30 피트 등입니다. GM은 장애물이나 어려운 지형을 고려하여 추가 이동 비용을 적용할 수 있습니다. 예를 들어, GM은 테이블, 벤치 또는 상대적으로 낮은 벽과 같은 작은 장벽을 건너는 데 5 피트의 추가 이동 비용이 든다고 결정할 수 있습니다. 또는 GM은 가파른 계단을 오르거나 물을 헤쳐나갈 때 전투원이 정상 속도의 절반으로만 움직일 수 있다고 규정할 수도 있습니다. 이는 전적으로 선택 사항이며 GM의 재량에 따릅니다. 전투원은 아군이 점령한 사각형을 방해받지 않고 이동합니다. 그러나 여전히 적용될 수 있는 다른 이동 제한이 적용됩니다. 전투원이 상대방과 인접한 사각형(수평, 수직 또는 대각선)에 들어가자마자 근접전을 벌이는 것으로 간주됩니다. 이는 즉시 이동 제한을 적용됩니다(근접 전투 섹션 참조). 해결해야 할 더 문제가 되는 이동 유형 중 하나는 두 전투원이 동일한 주도권으로 행동할 때의 동시 이동입니다. 이에 대해서는 특수 상황 섹션에서 설명합니다. 갑옷 / 침구류 라운드당 이동비율 평면도 이동 예제 갑옷없음 / 마법가죽 40 피트 가로/세로 8칸, 대각선으로 5칸까지 걸어간 후 공격가능하고, 가로/세로 최대 16개의 사각형 또는 대각선으로 11개의 사각형까지 달릴 수 있습니다 \ 가벼운 무게     갑옷없음 / 마법가죽 30 피트 가로/세로 6칸, 대각선으로 4칸까지 걸어간 후 공격가능하고, 가로/세로 최대 16개의 사각형 또는 대각선으로 8개의 사각형까지 달릴 수 있습니다 \ 무거운 무게     가죽갑옷 / 마법금속 ^^ ^^ \ 가벼운 무게     가죽갑옷 / 마법금속 20 피트 가로/세로 4칸, 대각선으로 3칸까지 걸어간 후 공격가능하고, 가로/세로 최대 8개의 사각형 또는 대각선으로 5개의 사각형까지 달릴 수 있습니다 \ 무거운 무게     금속갑옷 ^^ ^^ \ 가벼운 무게     금속갑옷 10 피트 가로/세로 2칸, 대각선으로 1칸까지 걸어간 후 공격가능하고, 가로/세로 최대 4개의 사각형 또는 대각선으로 3개의 사각형까지 달릴 수 있습니다 \ 무거운 무게     이동 예제 Tannen(이동 속도 20 피트)은 근접전에서 오우거와 교전하기 위해 앞으로 걸어갑니다. 그는 이번 라운드를 그의 검으로 공격할 수 있습니다. Doughbert(이동 속도 30 피트)는 대각선으로 걸어갑시다. 그는 숏보우로 이번 라운드를 공격할 수 있습니다. Mandross(이동 속도 40 피트)는 수평/수직 및 대각선 섞어서 이동합니다. 그는 이번 라운드에도 공격할 수 있습니다. Paladin(이동 속도 30 피트)가 도망갑니다. 그는 평소 이동 속도의 두 배까지 거리(예: 60피트)를 이동할 수 있지만 이번 라운드에는 공격할 수 없습니다. 미사일 발사 전투원이 미사일 공격을 수행하려면 두 가지 조건이 충족되어야 합니다. 상대는 사용 중인 미사일 무기의 범위 내에 있어야 합니다. 전투원은 상대방을 볼 수 있는 시야가 있어야 합니다. 전투원이 장애물을 통과하지 않고 자신의 사각형에 있는 한 지점에서 상대방의 사각형까지 직선을 그릴 수 있으면 시야가 확보됩니다. 그러나 전투원이 완전히 명확한 시야를 확보하지 못하더라도 GM은 장애물의 성격과 그것이 제공하는 엄폐 정도에 따라 미사일 공격을 허용할 수 있습니다. Basic Fantasy RPG 핵심 규칙의 조우 섹션에 있는 은폐 및 은폐 규칙을 따르세요. 아군이 점령한 사각형을 통한 미사일 발사는 GM의 재량에 따라 허용됩니다. 이러한 상황에서 GM은 아군의 존재로 인해 사격이 더 어려워진다고 판단되면(엄폐 및 은폐 규칙과 유사한 방식으로) “명중” 굴림에 페널티를 적용하기로 결정할 수 있습니다. 미사일 발사 예제 예제 1 Paladin은 Goblin 1에게 발사할 수 없습니다. 그는 시야가 없습니다. Paladin은 Goblin 2에 대한 명확한 시야를 갖고 있으며 정상적으로 발사할 수 있습니다. Goblin 3에는 부분 엄폐 기능이 있습니다. GM의 재량에 따라 Paladin은 적절한 페널티를 주어 발사할 수 있습니다. 예제 2 예제 1과 상황은 동일하지만 MapTool의 “전장 안개” 기능이 활성화되었습니다. 검은색으로 표시된 부분은 덮개로 인해 Paladin이 볼 수 없는 부분입니다. 이는 시선을 결정하는 데 유용한 기능이 될 수 있습니다. 근접전투 두 명의 상대 전투원이 서로 인접하게 되면(수평, 수직 또는 대각선으로) 근접전을 벌이는 것으로 간주됩니다. 이는 즉시 이동 제한을 적용됩니다. 공격할 차례가 되면 근접 전투원은 다음을 수행할 수 있습니다(이 순서대로). 상대방과의 근접전에서 벗어나지 않는 한 정상 이동 속도의 절반까지 이동합니다. 상대방은 전투원을 알고 있는 경우 이 움직임을 추적하기 위해 방향을 자유롭게 변경할 수 있습니다. 전투원이 상대방과의 근접전에서 벗어나고 싶다면 아래의 전투 철수 및 도주에 대한 규칙을 참조하세요. 방향을 한 번 변경합니다(즉, 특정 방향을 향하도록 회전). 앞이나 옆에 있는 5개의 사각형 중 하나에 있는 상대를 공격합니다. 전투원은 자신 뒤에 있는 세 칸 중 하나에 있는 상대를 공격할 수 없습니다. 전투원이 근접전에서 벗어나기를 원하는 경우 전투 철수 또는 도주라는 두 가지 옵션이 있습니다. 후자만이 전투원을 분리 사격의 위험에 빠뜨립니다(아래 참조). 전투 철수시 전투원이 정상 이동 속도의 최대 절반까지 근접 공격에서 물러날 수 있습니다. 전투원은 전투 철수를 수행한 후에도 범위 내에 상대가 있는 경우 정상적으로 공격할 수 있습니다. 전투원이 전투 철수(예: 일반적인 걷기 또는 달리기 속도)를 수행하지 않고 상대와 인접한 사각형에서 단순히 이동하는 경우 이는 도주로 분류되며 전투원은 분리 사격에 노출됩니다. 이를 통해 상대는 Basic Fantasy RPG 핵심 규칙의 조우 섹션에 있는 방어 이동 규칙에 따라 +2 명중굴림으로 즉시 공격을 할 수 있습니다. 이 분리 사격은 전투원이 특정 라운드에서 이미 수행했거나 아직 수행하지 않은 모든 행동에 추가됩니다. 전투원은 주어진 라운드에서 주어진 상대에 대해 단 한 번의 분리 사격을 할 수 있습니다. 근접 예제 예제 1 Tannen(이동 속도 20피트)이 Goblin과 근접전을 벌이고 있습니다. 그는 녹색 사각형(10 피트, 이동 속도의 절반) 중 하나로 이동할 수 있으며 방향을 한 번 변경한 다음 공격할 수 있습니다. 이 경우 Goblin은 Tannen의 움직임을 추적하기 위해 방향을 조정할 수도 있습니다. 또는 Tannen은 전투에서 철수하고(이동 속도의 절반인 10 피트) 주황색 사각형 중 하나로 이동할 수 있습니다. 그가 빨간색 사각형 중 하나로 이동하면(20 피트, 그의 최대 이동 속도 또는 그가 달리고 있는 경우 더 빠른 속도) 그는 도망가게 되며 Goblin의 분리 사격을 받게 됩니다. 예제 2 Doughbert(이동 30 피트)는 Goblin을 지나 서쪽으로 이동하려고 합니다. 그는 5 피트 또는 10 피트를 사각형 1과 2로 이동한 다음 원할 경우 미사일 공격을 가할 수 있습니다. 또는 그는 15 피트 또는 25 피트를 사각형 3 또는 4로 이동하여 고블린에게 근접 공격을 할 수 있습니다. (3번 사각형에서 4번 사각형으로의 근접전 이동이 4번 사각형으로 이동하는 데 25피트가 필요합니다.) 일반 속도의 절반, 즉 한 칸을 이동하는 데 10 피트의 비용이 듭니다). 5번 칸에 도달하려면 35피트의 이동 비용이 필요합니다. 이는 그가 달려야 한다는 것을 의미하므로 이번 라운드에는 근접 공격을 할 수 없습니다. 만약 그가 6칸 이상으로 달려간다면, 그는 근접전에서 나가게 되고 분리 사격을 받게 될 것입니다. 특별한 상황 뒤에서 공격하기 뒤에서 공격하기는 사각형 중 하나에서 전투원의 후방으로 수행되는 공격입니다. 소형 또는 중형 전투원은 근접 목적을 위한 세 개의 사각형을 가지고 있습니다(분명히 미사일 공격용으로 더 그렇습니다). 더 큰 전투원은 더 많은 수의 후방 사각형을 갖게 됩니다. 후방 공격에는 두 가지 유형이 있습니다. 일반 전투에서 발생하는 공격과 도둑의 특수 기습 공격입니다. 일반적인 전투의 경우 상대 뒤에서 공격하는 경우 일반적으로 Basic Fantasy RPG 핵심 규칙의 조우 섹션에 설명된 대로 +2 공격 보너스를 받습니다. 일반적으로 방어자가 자신의 상대를 모두 알고 있는 경우 공격자 중 한 명이 뒤에서 공격을 수행할 수 있는 상황을 활용하려면 최소한 세 명의 공격자가 필요합니다. 공격자의 수가 적다면 방어자는 항상 후방에 상대가 없도록 방향을 조정할 수 있습니다. 어떤 이유로든 방어자가 자신의 상대 중 한 명을 인식하지 못하는 경우(예: 투명화 또는 일종의 산만함을 통해) GM은 3명 미만의 공격자로 뒤에서 공격이 가능하다고 판단할 수 있습니다. 도둑의 몰래 공격(Basic Fantasy RPG 핵심 규칙의 캐릭터 섹션)에도 동일한 원칙이 적용됩니다. 일반적으로 말하자면, 주어진 전투에서 동일한 상대에게 그러한 공격은 단 한 번만 수행될 수 있습니다. 뒤에서 공격하기 예제 현재 방향을 기준으로 Goblin의 후면 사각형은 빨간색으로 표시됩니다. 두 명의 공격자(왼쪽)만 있으면 Goblin이 공격자 중 누구도 뒤에 있지 않도록 방향을 조정할 수 있습니다(고블린이 이러한 공격자를 알고 있다고 가정). 그러나 3명의 공격자(오른쪽)가 있는 경우 고블린은 뒤에서 적어도 한 번의 공격을 받을 수 있습니다(이 경우 Doughbert가 운이 좋은 친구입니다). 동시 이동 동시 이동, 즉 두 명 이상의 전투원이 동일한 주도권 점수로 행동하는 경우 평면도를 사용하여 해결하는 것이 다소 문제가 될 수 있습니다. 최신판에서 채택한 한 가지 접근 방식은 두 전투원이 동시에 행동할 가능성을 완전히 제거하는 것입니다. 더 큰 주도권 주사위(예: d20)는 동시 행동이 발생할 확률을 줄입니다. 각 전투원이 전투 순서에서 고유한 위치를 갖도록 추가 타이 브레이커(예: 가장 높은 민첩성 또는 추가 타이 브레이크 롤)를 사용할 수 있습니다. 그러한 접근 방식은 규칙 세트에 더 큰 영향을 미친다는 점을 명심하십시오. 예를 들어 주문 중단(Basic Fantasy RPG 핵심 규칙의 주문 섹션)은 동시 작업에 의존하는 한 측면입니다. 대안적인 접근 방식은 동일한 선제 점수로 행동하는 모든 전투원이 이동 점수가 가장 높은 전투원부터 시작하여 한 번에 5피트씩 교대로 이동할 수 있도록 하는 것입니다. 주어진 전투원의 움직임이 떨어지면 그들은 멈춥니다. 다른 사람들도 움직임이 없어질 때까지 계속 움직입니다.]]></summary></entry></feed>