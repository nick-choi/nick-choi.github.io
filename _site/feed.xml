<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-22T21:27:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nick Choi’s Works</title><subtitle>Nick Choi&apos;s Works
</subtitle><author><name>nickchoi</name></author><entry><title type="html">More Modern CMake - Your first CMakeLists.txt file</title><link href="http://localhost:4000/more-modern-cmake-your-first-file" rel="alternate" type="text/html" title="More Modern CMake - Your first CMakeLists.txt file" /><published>2024-01-20T00:00:00+09:00</published><updated>2024-01-20T00:00:00+09:00</updated><id>http://localhost:4000/00-more-modern-cmake-your-first-file</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-your-first-file"><![CDATA[<h1 id="your-first-cmakeliststxt-file">Your first CMakeLists.txt file</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>How little can I get away with in my CMakeLists?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>Understand the deep implications of <strong>cmake_minimum_version</strong></li>
      <li>Know how to set up a project</li>
      <li>Know how to make at least one target</li>
    </ul>
  </li>
</ul>

<h2 id="writing-a-cmakelists">Writing a CMakeLists</h2>

<p>The following file is fine for the following examples:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* simple.c or simple.cpp */
#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}
</code></pre></div></div>

<h3 id="starting-off">Starting off</h3>

<p>This is the simplest possible <strong>CMakeLists.txt</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.15)

project(MyProject)

add_executable(myexample simple.cpp)
</code></pre></div></div>

<p>Let’s look at the three lines:</p>

<ol>
  <li>The cmake_minimum_required command sets the policies so that the build is exactly like it would be on the listed version of CMake - in other words, CMake “dumbs itself down” to the version you request for any features that could produce a different build. This makes CMake almost perfectly backwards compatible.</li>
  <li>You need to be working on a project, and it needs at least a name. CMake assumes a CXX (that’s C++) and C mixed project if you don’t give any LANGUAGES.</li>
  <li>You need at least one library or executable to do anything interesting. The “thing” you make here is called a “target”, and the executable/library has the same name, by default, and it has to be unique in the project. You use add_executable for programs, and add_library for libraries.</li>
</ol>

<p>Those commands have a few extra arguments that you can give:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.15...3.25)

project(MyProject
  VERSION
    1.0
  DESCRIPTION
    "Very nice project"
  LANGUAGES
    CXX
)

add_executable(myexample simple.cpp)
</code></pre></div></div>
<ol>
  <li>You can specify a range of versions - this will cause the policies to be set to the highest supported value in that range. As a general rule, set the highest version you’ve tested with here.</li>
  <li>Projects can have versions, descriptions, and languages.</li>
  <li>Whitespace doesn’t matter. Be clear/pretty, or use cmake-format.</li>
</ol>

<h3 id="try-it-out">Try it out</h3>

<p>Build and run the example code with a CMakeLists.txt similar to the one above.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git
cd hsf-training-cmake-webpage/code/00-intro
</code></pre></div></div>

<h4 id="solution">Solution</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This is required in all CMakeLists Selecting a nice minimum version and range
cmake_minimum_required(VERSION 3.15...3.25)

# We can call the project anything we want Listing the language(s) avoids the C
# + CXX default
project(MyExample00 LANGUAGES C)

# We need an executable target
add_executable(simple_example simple.c)
</code></pre></div></div>

<h3 id="더-읽어보기">더 읽어보기</h3>

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/basics.html">Modern CMake basics</a>을 기반으로 함.</p>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>The cmake_minimum_version setting has deep implications</li>
  <li>You need a project line.</li>
  <li>You should prepare one or more targets to do anything interesting.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Your first CMakeLists.txt file Overview 질문 How little can I get away with in my CMakeLists? 목표 Understand the deep implications of cmake_minimum_version Know how to set up a project Know how to make at least one target Writing a CMakeLists The following file is fine for the following examples: /* simple.c or simple.cpp */ #include &lt;stdio.h&gt; int main() { printf("Hello, World!\n"); return 0; } Starting off This is the simplest possible CMakeLists.txt: cmake_minimum_required(VERSION 3.15) project(MyProject) add_executable(myexample simple.cpp) Let’s look at the three lines: The cmake_minimum_required command sets the policies so that the build is exactly like it would be on the listed version of CMake - in other words, CMake “dumbs itself down” to the version you request for any features that could produce a different build. This makes CMake almost perfectly backwards compatible. You need to be working on a project, and it needs at least a name. CMake assumes a CXX (that’s C++) and C mixed project if you don’t give any LANGUAGES. You need at least one library or executable to do anything interesting. The “thing” you make here is called a “target”, and the executable/library has the same name, by default, and it has to be unique in the project. You use add_executable for programs, and add_library for libraries. Those commands have a few extra arguments that you can give: cmake_minimum_required(VERSION 3.15...3.25) project(MyProject VERSION 1.0 DESCRIPTION "Very nice project" LANGUAGES CXX ) add_executable(myexample simple.cpp) You can specify a range of versions - this will cause the policies to be set to the highest supported value in that range. As a general rule, set the highest version you’ve tested with here. Projects can have versions, descriptions, and languages. Whitespace doesn’t matter. Be clear/pretty, or use cmake-format. Try it out Build and run the example code with a CMakeLists.txt similar to the one above. git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git cd hsf-training-cmake-webpage/code/00-intro Solution # This is required in all CMakeLists Selecting a nice minimum version and range cmake_minimum_required(VERSION 3.15...3.25) # We can call the project anything we want Listing the language(s) avoids the C # + CXX default project(MyExample00 LANGUAGES C) # We need an executable target add_executable(simple_example simple.c) 더 읽어보기 Modern CMake basics을 기반으로 함. 핵심사항 The cmake_minimum_version setting has deep implications You need a project line. You should prepare one or more targets to do anything interesting.]]></summary></entry><entry><title type="html">More Modern CMake - Building with CMake</title><link href="http://localhost:4000/more-modern-cmake-build-with-cmake" rel="alternate" type="text/html" title="More Modern CMake - Building with CMake" /><published>2024-01-18T00:00:00+09:00</published><updated>2024-01-18T00:00:00+09:00</updated><id>http://localhost:4000/18-more-modern-cmake-building-with-cmake</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-build-with-cmake"><![CDATA[<h1 id="building-with-cmake">Building With CMake</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>프로젝트를 어떻게 빌드하는가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>CMake 설치에 대한 참고.</li>
      <li>기존 프로젝트를 빌드하는 방법을 알아보자.</li>
      <li>빌드를 사용자 정의한다.</li>
      <li>몇 가지 기본적인 디버깅을 수행하는 방법을 알아보자.</li>
    </ul>
  </li>
</ul>

<h2 id="cmake-설치">CMake 설치</h2>

<p>거의 모든 곳에 최신 버전의 CMake를 설치하는 데 일반적으로 한 줄 또는 두 줄에 불과하다. <a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">CMake 설명</a>을 참조.</p>

<h2 id="cmake-로-빌드하기">CMake 로 빌드하기</h2>

<p>CMake를 작성하기 전에 CMake를 실행하여 만드는 방법을 알고 있는지 확인하겠다. 이는 거의 모든 CMake 프로젝트에 해당된다.</p>

<h3 id="try-it-out">Try it out</h3>

<p>프로젝트를 하나 가져와서 빌드해 보자. 재미삼아 CLI11을 빌드해본다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/CLIUtils/CLI11.git
cd CLI11
</code></pre></div></div>

<p>이제 새로 다운로드된 디렉토리에서 모던 CMake(3.14) 빌드 절차를 시도해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake -S . -B build
cmake --build build
cmake --build build -t test
</code></pre></div></div>

<p>빌드 디렉터리(<strong>-B</strong>)가 존재하지 않을 경우 빌드 디렉터리를 만들고, 소스 디렉터리는 <strong>-S</strong>로 정의한다. CMake는 기본적으로 makefile을 구성하고 생성할 뿐만 아니라 모든 옵션을 기본 설정으로 설정하고 이를 빌드 디렉터리에 있는 <strong>CMakeCache.txt</strong>라는 파일에 캐시한다. 관례적으로 대부분의 패키지의 <strong>.gitignore</strong> 파일에서 무시하려면 <strong>build</strong>라는 단어가 있어야 한다.</p>

<p>그런 다음 빌드 시스템을 호출할 수 있다(2번째 줄). <strong>make</strong>(기본값), <strong>ninja</strong> 또는 IDE 기반 시스템을 사용했는지 여부에 관계없이 동일한 명령을 사용하여 빌드할 수 있다. <strong>-j 2</strong>를 추가하여 두 개의 코어에 빌드하거나 <strong>-v</strong>를 추가하여 빌드에 사용된 명령을 자세히 표시할 수 있다.</p>

<p>마지막으로 “test” 대상을 기본 빌드 시스템에 전달하여 여기에서 테스트를 실행할 수도 있다. <strong>-t</strong>(CMake 3.15 이전에는 <strong>–target</strong>)를 사용하면 대상을 선택할 수 있다. CMake 3.15+에는 기본 빌드 시스템을 호출하지 않고 설치를 수행하는 <strong>cmake &lt;dir&gt; –install</strong> 명령도 있다!</p>

<h3 id="소스-안에서-빌드하는-것의-경고">소스 안에서 빌드하는 것의 경고</h3>

<p>소스 디렉토리에서 절대로 “소스 내” 빌드 - 즉, <strong>cmake .</strong> 를 실행하면 안된다. 소스 디렉토리를 빌드 결과물, CMake 구성 파일로 오염시키고 소스 외부 빌드를 비활성화한다. 몇 개의 패키지는 소스 디렉토리가 빌드 디렉토리 내부에 위치하는 것조차 허용하지 않는다. 그런 경우 상대 경로(<strong>..</strong>)를 적절히 변경해야 한다.</p>

<p>간단히 설명하자면, CMake는 빌드 디렉토리의 소스 디렉토리 또는 어디에서나 기존 빌드 디렉토리를 가리킬 수 있다.</p>

<h3 id="다른-구문-선택">다른 구문 선택</h3>

<p>완전성을 위해 고전적인 방법이 보여주는 것이 좋겠다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir build
cd build
cmake ..
make
make test
</code></pre></div></div>

<p>여기에는 몇 가지 단점이 있다. 디렉터리가 이미 존재하는 경우 <strong>-p</strong>를 추가해야 하지만 Windows에서는 작동하지 않는다. 당신은 그 디렉토리 안에 있기 때문에 빌드 디렉토리 사이를 쉽게 변경할 수 없다. 라인이 더 많아지고, 빌드 디렉터리로 변경하는 것을 잊어버린 경우 <strong>cmake ..</strong> 대신 <strong>cmake .</strong> 를 사용한다. 그럴 경우 소스 디렉토리를 오염시킬 수 있다.</p>

<h2 id="컴파일러-선택하기">컴파일러 선택하기</h2>

<p>컴파일러 선택은 빈 디렉터리에서 처음 실행할 때 수행되어야 한다. CMake 구문 자체는 아니지만 익숙하지 않을 수도 있다. Clang을 선택하려면:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC=clang CXX=clang++ cmake -S . -B build
</code></pre></div></div>

<p>그러면 <strong>CC</strong> 및 <strong>CXX</strong>에 대해 bash에서 환경 변수로 설정되고 CMake는 해당 변수를 고려할 것이다. 이렇게 하면 해당 한 라인에 대해서만 설정되지만, 필요한 경우는 딱 저 시간 뿐이다. 이후 CMake는 해당 값에서 추론한 경로를 계속 사용한다.</p>

<h2 id="생성기-선택하기">생성기 선택하기</h2>

<p>다양한 툴을 사용하여 빌드할 수 있다. <strong>make</strong>는 일반적으로 기본값이다. CMake가 시스템에서 알고 있는 모든 툴을 보려면 다음을 실행하자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake --help
</code></pre></div></div>

<p>그리고 <strong>-G”My Tool”</strong>을 사용하여 툴을 선택할 수 있다(툴 이름에 공백이 있는 경우에만 큰따옴표가 필요). 컴파일러와 마찬가지로 디렉터리에서 처음 CMake 호출 시 툴을 선택해야 한다. <strong>build</strong> 및 <strong>build-xcode</strong>와 같이 여러 빌드 디렉터리를 자유롭게 사용할 수 있다. 환경 변수 <strong>CMAKE_GENERATOR</strong>를 설정하여 기본 생성기(CMake 3.15+)를 조작할 수 있다. makefile은 <strong>make -j2</strong>와 같이 명시적으로 여러 스레드를 전달하는 경우에만 병렬로 실행되는 반면, Ninja는 자동으로 병렬로 실행된다. 최근 버전의 CMake에서도 <strong>-j 2</strong>와 같은 병렬화 옵션을 <strong>cmake –build .</strong> 명령에 직접 전달할 수 있다.</p>

<h2 id="옵션-설정하기">옵션 설정하기</h2>

<p><strong>-D</strong>를 사용하여 CMake에서 옵션을 설정한다. <strong>-L</strong>을 사용하면 옵션 목록을 볼 수 있고, <strong>-LH</strong>를 사용하면 사람이 읽을 수 있는 도움말 목록을 볼 수 있다.</p>

<h2 id="상세-및-부분-빌드">상세 및 부분 빌드</h2>

<p>다시 말하지만, CMake는 아니지만 <strong>make</strong>와 같은 커맨드 라인 빌드 툴을 사용하는 경우, 자세한 빌드를 얻을 수 있다:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake --build build -v
</code></pre></div></div>
<p>make를 직접 사용하는 경우, <strong>VERBOSE=1 make</strong> 또는 <strong>make VERBOSE=1</strong>이라고 쓸 수 있으며, 비록 명령 뒤에 변수를 쓰는 것은 <strong>make</strong>의 기능이고 일반적인 커맨드 라인 방식이 아니지만, make 역시 올바른 작업을 수행할 것이다.</p>

<p>CMake에서 정의한 라이브러리 또는 실행 파일의 이름과 같은 대상을 지정하여 빌드의 일부만 빌드할 수도 있으며 make는 해당 대상만 빌드한다. 이것이 <strong>–target</strong>(CMake 3.15+에서는 <strong>-t</strong>) 옵션이다.</p>

<h2 id="옵션들">옵션들</h2>

<p>CMake는 캐시된 옵션을 지원한다. CMake의 변수는 “캐시됨”으로 표시될 수 있는데, 이 의미는 변수가 발견되면 캐시(빌드 디렉터리에 있는 <strong>CMakeCache.txt</strong>라는 파일)에 기록된다는 의미이다. <strong>-D</strong>를 사용하여 커맨드라인에서 캐시된 옵션 값을 미리 설정(또는 변경)할 수 있다. CMake가 캐시된 변수를 찾을 때는 기존 값을 사용하고 덮어쓰지 않는다.</p>

<h3 id="표준-옵션들">표준 옵션들</h3>

<p>이는 대부분의 패키지에 대한 일반적인 CMake 옵션들이다:</p>
<ul>
  <li><strong>CMAKE_BUILD_TYPE</strong>: <strong>Release</strong>, <strong>RelWithDebInfo</strong>, <strong>Debug</strong> 등에서 선택</li>
  <li><strong>CMAKE_INSTALL_PREFIX</strong>: 설치할 위치. UNIX의 시스템 설치는 종종 <strong>/usr/local</strong>(기본값)이고, 사용자 디렉터리는 대개 <strong>~/.local</strong>이거나 폴더를 선택할 수 있다.</li>
  <li><strong>BUILD_SHARED_LIBS</strong>: <strong>ON</strong> 또는 <strong>OFF</strong>로 설정하여 공유 라이브러리의 기본값을 제어할 수 있다. (단, 작성자는 기본값을 사용하는 대신 명시적으로 둘 중 하나를 선택할 수 있다)</li>
  <li><strong>BUILD_TESTING</strong>: 이는 테스트를 활성화하기 위한 일반적인 이름이다. 다만 때때로 적절한 이유로 인해 모든 패키지에서 이를 사용하는 것은 아니다.</li>
</ul>

<h3 id="시도해보기">시도해보기</h3>

<p>복제한 CLI11 저장소에서:</p>

<ul>
  <li>어떤 옵션을 사용할 수 있는지 확인</li>
  <li>값을 변경한다; <strong>CMAKE_CXX_STANDARD</strong>를 14로 설정하거나 테스트를 끌 수도 있다.</li>
  <li><strong>CMAKE_INSTALL_PREFIX=install</strong>로 구성한 다음 해당 로컬 디렉터리에 설치한다. 거기에서 보여지는 지 확인하라!</li>
</ul>

<h2 id="cmake-파일들-디버깅">CMake 파일들 디버깅</h2>

<p>이미 빌드에 대한 자세한 출력을 언급했지만 자세한 CMake 구성 출력도 볼 수 있다. <strong>–trace</strong> 옵션은 실행되는 CMake의 모든 라인을 인쇄한다. 이것은 매우 장황하기 때문에, CMake 3.7에는 <strong>–trace-source=”filename”</strong>을 추가하여 실행 시 관심있는 파일의 모든 실행 라인을 출력한다. 디버깅에 관심이 있는 파일 이름을 선택하면(CMakeLists.txt를 디버깅하는 경우 모든 이름이 동일하므로 일반적으로 상위 디렉터리 사용) 해당 파일에서 실행되는 라인만 볼 수 있다. 굉장히 유용하다!</p>

<h3 id="시도해보기-1">시도해보기</h3>

<p>소스 디렉터리에서 다음을 실행한다:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake build --trace-source="CMakeLists.txt"
</code></pre></div></div>

<h3 id="답해보자">답해보자.</h3>

<p>질문: <strong>cmake build</strong>는 무엇이든 빌드하는가?
답 : 아니, 여기서 “빌드”는 디렉터리이다. 이것은 (빌드 시스템 파일을) 구성한다. 빌드하려면 디렉터리 앞에 <strong>–build</strong>를 추가하거나 <strong>make</strong>와 같은 빌드 툴을 사용한다.</p>

<h3 id="더-읽어보기">더 읽어보기</h3>

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/running.html">Modern CMake intro/running</a>을 기반으로 함.</p>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>프로젝트를 빌드.</li>
  <li>소스 외부 빌드를 사용하자.</li>
  <li>빌드 옵션 및 사용자 정의.</li>
  <li>CMakeList를 쉽게 디버그.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Building With CMake Overview 질문 프로젝트를 어떻게 빌드하는가? 목표 CMake 설치에 대한 참고. 기존 프로젝트를 빌드하는 방법을 알아보자. 빌드를 사용자 정의한다. 몇 가지 기본적인 디버깅을 수행하는 방법을 알아보자. CMake 설치 거의 모든 곳에 최신 버전의 CMake를 설치하는 데 일반적으로 한 줄 또는 두 줄에 불과하다. CMake 설명을 참조. CMake 로 빌드하기 CMake를 작성하기 전에 CMake를 실행하여 만드는 방법을 알고 있는지 확인하겠다. 이는 거의 모든 CMake 프로젝트에 해당된다. Try it out 프로젝트를 하나 가져와서 빌드해 보자. 재미삼아 CLI11을 빌드해본다. git clone https://github.com/CLIUtils/CLI11.git cd CLI11 이제 새로 다운로드된 디렉토리에서 모던 CMake(3.14) 빌드 절차를 시도해보자. cmake -S . -B build cmake --build build cmake --build build -t test 빌드 디렉터리(-B)가 존재하지 않을 경우 빌드 디렉터리를 만들고, 소스 디렉터리는 -S로 정의한다. CMake는 기본적으로 makefile을 구성하고 생성할 뿐만 아니라 모든 옵션을 기본 설정으로 설정하고 이를 빌드 디렉터리에 있는 CMakeCache.txt라는 파일에 캐시한다. 관례적으로 대부분의 패키지의 .gitignore 파일에서 무시하려면 build라는 단어가 있어야 한다. 그런 다음 빌드 시스템을 호출할 수 있다(2번째 줄). make(기본값), ninja 또는 IDE 기반 시스템을 사용했는지 여부에 관계없이 동일한 명령을 사용하여 빌드할 수 있다. -j 2를 추가하여 두 개의 코어에 빌드하거나 -v를 추가하여 빌드에 사용된 명령을 자세히 표시할 수 있다. 마지막으로 “test” 대상을 기본 빌드 시스템에 전달하여 여기에서 테스트를 실행할 수도 있다. -t(CMake 3.15 이전에는 –target)를 사용하면 대상을 선택할 수 있다. CMake 3.15+에는 기본 빌드 시스템을 호출하지 않고 설치를 수행하는 cmake &lt;dir&gt; –install 명령도 있다! 소스 안에서 빌드하는 것의 경고 소스 디렉토리에서 절대로 “소스 내” 빌드 - 즉, cmake . 를 실행하면 안된다. 소스 디렉토리를 빌드 결과물, CMake 구성 파일로 오염시키고 소스 외부 빌드를 비활성화한다. 몇 개의 패키지는 소스 디렉토리가 빌드 디렉토리 내부에 위치하는 것조차 허용하지 않는다. 그런 경우 상대 경로(..)를 적절히 변경해야 한다. 간단히 설명하자면, CMake는 빌드 디렉토리의 소스 디렉토리 또는 어디에서나 기존 빌드 디렉토리를 가리킬 수 있다. 다른 구문 선택 완전성을 위해 고전적인 방법이 보여주는 것이 좋겠다. mkdir build cd build cmake .. make make test 여기에는 몇 가지 단점이 있다. 디렉터리가 이미 존재하는 경우 -p를 추가해야 하지만 Windows에서는 작동하지 않는다. 당신은 그 디렉토리 안에 있기 때문에 빌드 디렉토리 사이를 쉽게 변경할 수 없다. 라인이 더 많아지고, 빌드 디렉터리로 변경하는 것을 잊어버린 경우 cmake .. 대신 cmake . 를 사용한다. 그럴 경우 소스 디렉토리를 오염시킬 수 있다. 컴파일러 선택하기 컴파일러 선택은 빈 디렉터리에서 처음 실행할 때 수행되어야 한다. CMake 구문 자체는 아니지만 익숙하지 않을 수도 있다. Clang을 선택하려면: CC=clang CXX=clang++ cmake -S . -B build 그러면 CC 및 CXX에 대해 bash에서 환경 변수로 설정되고 CMake는 해당 변수를 고려할 것이다. 이렇게 하면 해당 한 라인에 대해서만 설정되지만, 필요한 경우는 딱 저 시간 뿐이다. 이후 CMake는 해당 값에서 추론한 경로를 계속 사용한다. 생성기 선택하기 다양한 툴을 사용하여 빌드할 수 있다. make는 일반적으로 기본값이다. CMake가 시스템에서 알고 있는 모든 툴을 보려면 다음을 실행하자. cmake --help 그리고 -G”My Tool”을 사용하여 툴을 선택할 수 있다(툴 이름에 공백이 있는 경우에만 큰따옴표가 필요). 컴파일러와 마찬가지로 디렉터리에서 처음 CMake 호출 시 툴을 선택해야 한다. build 및 build-xcode와 같이 여러 빌드 디렉터리를 자유롭게 사용할 수 있다. 환경 변수 CMAKE_GENERATOR를 설정하여 기본 생성기(CMake 3.15+)를 조작할 수 있다. makefile은 make -j2와 같이 명시적으로 여러 스레드를 전달하는 경우에만 병렬로 실행되는 반면, Ninja는 자동으로 병렬로 실행된다. 최근 버전의 CMake에서도 -j 2와 같은 병렬화 옵션을 cmake –build . 명령에 직접 전달할 수 있다. 옵션 설정하기 -D를 사용하여 CMake에서 옵션을 설정한다. -L을 사용하면 옵션 목록을 볼 수 있고, -LH를 사용하면 사람이 읽을 수 있는 도움말 목록을 볼 수 있다. 상세 및 부분 빌드 다시 말하지만, CMake는 아니지만 make와 같은 커맨드 라인 빌드 툴을 사용하는 경우, 자세한 빌드를 얻을 수 있다: cmake --build build -v make를 직접 사용하는 경우, VERBOSE=1 make 또는 make VERBOSE=1이라고 쓸 수 있으며, 비록 명령 뒤에 변수를 쓰는 것은 make의 기능이고 일반적인 커맨드 라인 방식이 아니지만, make 역시 올바른 작업을 수행할 것이다. CMake에서 정의한 라이브러리 또는 실행 파일의 이름과 같은 대상을 지정하여 빌드의 일부만 빌드할 수도 있으며 make는 해당 대상만 빌드한다. 이것이 –target(CMake 3.15+에서는 -t) 옵션이다. 옵션들 CMake는 캐시된 옵션을 지원한다. CMake의 변수는 “캐시됨”으로 표시될 수 있는데, 이 의미는 변수가 발견되면 캐시(빌드 디렉터리에 있는 CMakeCache.txt라는 파일)에 기록된다는 의미이다. -D를 사용하여 커맨드라인에서 캐시된 옵션 값을 미리 설정(또는 변경)할 수 있다. CMake가 캐시된 변수를 찾을 때는 기존 값을 사용하고 덮어쓰지 않는다. 표준 옵션들 이는 대부분의 패키지에 대한 일반적인 CMake 옵션들이다: CMAKE_BUILD_TYPE: Release, RelWithDebInfo, Debug 등에서 선택 CMAKE_INSTALL_PREFIX: 설치할 위치. UNIX의 시스템 설치는 종종 /usr/local(기본값)이고, 사용자 디렉터리는 대개 ~/.local이거나 폴더를 선택할 수 있다. BUILD_SHARED_LIBS: ON 또는 OFF로 설정하여 공유 라이브러리의 기본값을 제어할 수 있다. (단, 작성자는 기본값을 사용하는 대신 명시적으로 둘 중 하나를 선택할 수 있다) BUILD_TESTING: 이는 테스트를 활성화하기 위한 일반적인 이름이다. 다만 때때로 적절한 이유로 인해 모든 패키지에서 이를 사용하는 것은 아니다. 시도해보기 복제한 CLI11 저장소에서: 어떤 옵션을 사용할 수 있는지 확인 값을 변경한다; CMAKE_CXX_STANDARD를 14로 설정하거나 테스트를 끌 수도 있다. CMAKE_INSTALL_PREFIX=install로 구성한 다음 해당 로컬 디렉터리에 설치한다. 거기에서 보여지는 지 확인하라! CMake 파일들 디버깅 이미 빌드에 대한 자세한 출력을 언급했지만 자세한 CMake 구성 출력도 볼 수 있다. –trace 옵션은 실행되는 CMake의 모든 라인을 인쇄한다. 이것은 매우 장황하기 때문에, CMake 3.7에는 –trace-source=”filename”을 추가하여 실행 시 관심있는 파일의 모든 실행 라인을 출력한다. 디버깅에 관심이 있는 파일 이름을 선택하면(CMakeLists.txt를 디버깅하는 경우 모든 이름이 동일하므로 일반적으로 상위 디렉터리 사용) 해당 파일에서 실행되는 라인만 볼 수 있다. 굉장히 유용하다! 시도해보기 소스 디렉터리에서 다음을 실행한다: cmake build --trace-source="CMakeLists.txt" 답해보자. 질문: cmake build는 무엇이든 빌드하는가? 답 : 아니, 여기서 “빌드”는 디렉터리이다. 이것은 (빌드 시스템 파일을) 구성한다. 빌드하려면 디렉터리 앞에 –build를 추가하거나 make와 같은 빌드 툴을 사용한다. 더 읽어보기 Modern CMake intro/running을 기반으로 함. 핵심사항 프로젝트를 빌드. 소스 외부 빌드를 사용하자. 빌드 옵션 및 사용자 정의. CMakeList를 쉽게 디버그.]]></summary></entry><entry><title type="html">More Modern CMake - Introduction</title><link href="http://localhost:4000/more-modern-cmake-introduction" rel="alternate" type="text/html" title="More Modern CMake - Introduction" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/00-more-modern-cmake-introduction</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-introduction"><![CDATA[<h1 id="introduction">Introduction</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다</li>
      <li>CMake가 사용되는 이유를 이해한다.</li>
      <li>최신 CMake가 더 좋다.</li>
    </ul>
  </li>
</ul>

<p>코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다.</p>

<p>그래서 사람들은 <strong>빌드 시스템</strong>을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다.</p>

<p>그러나 이는 다음과 같다.</p>
<ul>
  <li>대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다.</li>
  <li>플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다.</li>
  <li>종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다.</li>
  <li>확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다.</li>
</ul>

<p>빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다.</p>

<p>CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다.</p>

<p>요약하면 다음과 같은 경우 CMake를 사용해야 한다.</p>
<ul>
  <li>하드 코딩 경로를 피하고 싶은 경우</li>
  <li>두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우</li>
  <li>CI(지속적 통합)를 사용하고 싶은 경우</li>
  <li>다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음)</li>
  <li>여러 컴파일러를 지원하고 싶은 경우</li>
  <li>IDE를 사용하고 싶지만 항상 그렇지는 않을 경우</li>
  <li>플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우</li>
  <li>라이브러리를 이용하고 싶은 경우</li>
  <li>Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우</li>
  <li>디버거를 사용하려는 경우</li>
</ul>

<h1 id="more-modern-cmake">(More) Modern CMake</h1>

<p>CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 <a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">여기</a>를 참조하라.</p>

<p>왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. <strong>모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다.</strong> CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다.</p>

<h2 id="모던-cmake의-예">모던 CMake의 예</h2>
<ul>
  <li>
    <p>잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다.</p>
  </li>
  <li>
    <p>CMake 3.1+가 필요한 경우 <strong>CXX_STANDARD</strong>를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 <strong>compile_features</strong>를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다.</p>
  </li>
  <li>
    <p>CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 <strong>compile_features</strong>를 사용하여 <strong>cxx_std_11</strong>과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다.</p>
  </li>
</ul>

<h1 id="2023년-최소한의-선택">2023년 최소한의 선택</h1>

<p>로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다.</p>

<p>지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다.</p>

<h2 id="선택할-최소-항목---os-지원">선택할 최소 항목 - OS 지원:</h2>

<ul>
  <li>3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라.</li>
  <li>3.7: Debian의 오래된 Stable.</li>
  <li>3.10: Ubuntu 18.04.</li>
  <li>3.11: CentOS 8(단, EPEL 또는 AppSteams 사용)</li>
  <li>3.13: Debian Stable.</li>
  <li>3.16: Ubuntu 20.04.</li>
  <li>3.19: 최초로 Apple Silicon을 지원.</li>
  <li>최신: pip/conda-forge/homebew/chocolaty 등</li>
</ul>

<h2 id="선택할-최소-항목---기능">선택할 최소 항목 - 기능:</h2>

<ul>
  <li>3.8: C++ 메타 기능, CUDA 등 다양한 기능</li>
  <li>3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE</li>
  <li>3.12: C++20, cmake –build build -j N, SHELL:, FindPython</li>
  <li>3.14/3.15: CLI, FindPython 업데이트</li>
  <li>3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능</li>
  <li>3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍</li>
  <li>3.20: C++23, CUDARCHS, IntelLLVM, NVHPC</li>
  <li>3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS</li>
  <li>3.24: 다운로드와 패키지 찾기 통합, –fresh</li>
  <li>3.25: C++26 지원, CUDA용 LTO</li>
</ul>

<h1 id="다른-소스들">다른 소스들</h1>

<p>웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다.</p>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/">Modern CMake</a>: 이 튜토리얼의 출처가 되는 책.</li>
  <li><a href="https://cmake.org/cmake/help/latest/">The official help</a>: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐.</li>
  <li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a>: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록.</li>
  <li><a href="https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/">Embracing Modern CMake</a>: 용어에 대한 좋은 설명이 포함된 게시물.</li>
  <li><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">It’s time to do CMake Right</a>: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음.</li>
  <li><a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/">The Ultimate Guide to Modern CMake</a>: 비슷한 의도를 지닌 약간 오래된 게시물.</li>
  <li><a href="https://youtu.be/y7ndUhdQuU8">More Modern CMake</a>: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다.</li>
  <li><a href="https://github.com/toeb/moderncmake">toeb/moderncmake</a>: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제</li>
</ul>

<h1 id="핵심사항">핵심사항</h1>

<ul>
  <li>빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다.</li>
  <li>빌드 시스템 생성기는 일반적인 관계를 설명한다.</li>
  <li>모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Introduction Overview 질문 빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가? 목표 빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다 CMake가 사용되는 이유를 이해한다. 최신 CMake가 더 좋다. 코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다. 그래서 사람들은 빌드 시스템을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다. 그러나 이는 다음과 같다. 대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다. 플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다. 종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다. 확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다. 빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다. CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다. 요약하면 다음과 같은 경우 CMake를 사용해야 한다. 하드 코딩 경로를 피하고 싶은 경우 두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우 CI(지속적 통합)를 사용하고 싶은 경우 다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음) 여러 컴파일러를 지원하고 싶은 경우 IDE를 사용하고 싶지만 항상 그렇지는 않을 경우 플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우 라이브러리를 이용하고 싶은 경우 Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우 디버거를 사용하려는 경우 (More) Modern CMake CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 여기를 참조하라. 왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. 모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다. CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다. 모던 CMake의 예 잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다. CMake 3.1+가 필요한 경우 CXX_STANDARD를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 compile_features를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다. CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 compile_features를 사용하여 cxx_std_11과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다. 2023년 최소한의 선택 로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다. 지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다. 선택할 최소 항목 - OS 지원: 3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라. 3.7: Debian의 오래된 Stable. 3.10: Ubuntu 18.04. 3.11: CentOS 8(단, EPEL 또는 AppSteams 사용) 3.13: Debian Stable. 3.16: Ubuntu 20.04. 3.19: 최초로 Apple Silicon을 지원. 최신: pip/conda-forge/homebew/chocolaty 등 선택할 최소 항목 - 기능: 3.8: C++ 메타 기능, CUDA 등 다양한 기능 3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE 3.12: C++20, cmake –build build -j N, SHELL:, FindPython 3.14/3.15: CLI, FindPython 업데이트 3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능 3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍 3.20: C++23, CUDARCHS, IntelLLVM, NVHPC 3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS 3.24: 다운로드와 패키지 찾기 통합, –fresh 3.25: C++26 지원, CUDA용 LTO 다른 소스들 웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다. Modern CMake: 이 튜토리얼의 출처가 되는 책. The official help: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐. Effective Modern CMake: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록. Embracing Modern CMake: 용어에 대한 좋은 설명이 포함된 게시물. It’s time to do CMake Right: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음. The Ultimate Guide to Modern CMake: 비슷한 의도를 지닌 약간 오래된 게시물. More Modern CMake: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다. toeb/moderncmake: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제 핵심사항 빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다. 빌드 시스템 생성기는 일반적인 관계를 설명한다. 모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.]]></summary></entry><entry><title type="html">More Modern CMake</title><link href="http://localhost:4000/2024/01/15/00-more-modern-cmake.html" rel="alternate" type="text/html" title="More Modern CMake" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/2024/01/15/00-more-modern-cmake</id><content type="html" xml:base="http://localhost:4000/2024/01/15/00-more-modern-cmake.html"><![CDATA[<p>More Modern CMake 공부하려고 대충 번역함. 구글과 파파고 사용해서 내가 보기 쉽게 정리</p>

<p>출처 : <a href="https://hsf-training.github.io/hsf-training-cmake-webpage/">More Modern CMake</a></p>

<p>HSF CMake 튜토리얼에 오신 것을 환영한다! 이 튜토리얼의 목적은 CMake 사용의 기본 사항을 다루는 것이다. 이 튜토리얼은 CMake 3.15+에 초점을 맞춘 온라인 서적 Modern CMake를 기반으로 한다. 이것은 CMake의 “More Modern” 시대(대략 3.12+로 정의됨)에 해당하며 CMake π(3.14) 및 3.15의 환상적인 명령 개선이 포함된다. 이 글을 쓰는 시점의 현재 버전은 CMake 3.21이다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="/more-modern-cmake-introduction">Introduction</a></li>
  <li><a href="/more-modern-cmake-build-with-cmake">Building With CMake</a></li>
  <li><a href="/more-modern-cmake-your-first-file">Your first file CMakeLists.txt file</a></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[More Modern CMake 공부하려고 대충 번역함. 구글과 파파고 사용해서 내가 보기 쉽게 정리 출처 : More Modern CMake HSF CMake 튜토리얼에 오신 것을 환영한다! 이 튜토리얼의 목적은 CMake 사용의 기본 사항을 다루는 것이다. 이 튜토리얼은 CMake 3.15+에 초점을 맞춘 온라인 서적 Modern CMake를 기반으로 한다. 이것은 CMake의 “More Modern” 시대(대략 3.12+로 정의됨)에 해당하며 CMake π(3.14) 및 3.15의 환상적인 명령 개선이 포함된다. 이 글을 쓰는 시점의 현재 버전은 CMake 3.21이다. 목차 Introduction Building With CMake Your first file CMakeLists.txt file]]></summary></entry><entry><title type="html">Unity Prototype Step2</title><link href="http://localhost:4000/2023/10/26/18-unity-client-step2.html" rel="alternate" type="text/html" title="Unity Prototype Step2" /><published>2023-10-26T00:00:00+09:00</published><updated>2023-10-26T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/26/18-unity-client-step2</id><content type="html" xml:base="http://localhost:4000/2023/10/26/18-unity-client-step2.html"><![CDATA[<h1 id="2-캐릭터-클래스-정의">2. 캐릭터 클래스 정의</h1>
<ul>
  <li>프로토타입에 사용될 예제들은 페이지 마지막에 정리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : type // 인간,드워프
  Class : type // 전사, 성직자
  Level : uint // 레벨
  Movement : uint //이동 가능 칸수
  CurrentHitPoint : uint //현재 HP
  MaxHitPoint : uint //최대 HP
  Strength : uint // 힘, 일단 1
  AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스
  AttackRange : uint //공격범위, 근거리일 경우는 1
  ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11
  WeaponType : type //한손
  WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage)
}
</code></pre></div></div>

<h1 id="3-두-캐릭터의-hp-표시하기">3. 두 캐릭터의 HP 표시하기</h1>

<ul>
  <li>Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-hpbar.png" alt="캐릭터 HP" /></p>

<h1 id="4-커맨드-메뉴-구현하기">4. 커맨드 메뉴 구현하기</h1>

<ul>
  <li>해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행</li>
  <li>한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-menu.png" alt="캐릭터 메뉴" /></p>

<h2 id="1-이동">1. 이동</h2>

<ul>
  <li>이동 메뉴를 선택시 <a href="/unity-prototype-step1">이전페이지</a> 와 동일하게 이동할 수 있는 영역이 표시됨</li>
  <li>영역은 Character Class의 Movement 값을 적용하여 표시</li>
  <li>영역 클릭시 해당 타일로 이동</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-move.png" alt="캐릭터 이동" /></p>

<h2 id="2-공격">2. 공격</h2>

<ul>
  <li>영역은 Character Class의 AttackRange 값을 적용하여 표시</li>
  <li>영역 클릭시 아래 공격 로직을 적용</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-attack.png" alt="캐릭터 공격" /></p>

<h2 id="3-대기">3. 대기</h2>

<ul>
  <li>따로 영역 필요없이 상대방에게 턴을 넘김</li>
</ul>

<h1 id="5-공격-적용">5. 공격 적용</h1>
<ul>
  <li>이번에는 따로 무기없이 한손, 근거리 전투로만 한정</li>
</ul>

<h2 id="명중-굴림">명중 굴림</h2>

<ul>
  <li>공격이 성공하는지 체크하는 로직으로 <strong>공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공</strong></li>
  <li>
    <p><a href="/basic-fantasy/encounter#공격하기">Basic Fantasy - 조우</a>의 공격하기 설명 참고</p>
  </li>
  <li>명중 굴림 성공 유무 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="피해">피해</h2>

<ul>
  <li>명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영</li>
  <li>
    <p><a href="/basic-fantasy/encounter#피해">Basic Fantasy - 조우</a>의 피해 설명 참고</p>
  </li>
  <li>피해 산정 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>피해 = Math.Rand(WeaponDamage) + Strength
</code></pre></div>    </div>
  </li>
  <li>상대편 HP 적용, 상대편 HPBar에 업데이트
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CurrentHitPoint = CurrentHitPoint - 피해
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="공격턴-마무리">공격턴 마무리</h2>

<ul>
  <li>상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리</li>
</ul>

<h1 id="5-프로토타입에-적용할-chracter-예제-데이터">5. 프로토타입에 적용할 Chracter 예제 데이터</h1>
<ul>
  <li>드워프/전사</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Dwarf
  Class : Fighter
  Level : 1
  Movement : 2
  CurrentHitPoint : 15
  MaxHitPoint : 15
  Strength : 2
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 6
}
</code></pre></div></div>

<ul>
  <li>인간/성직자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Human
  Class : Cleric
  Level : 1
  Movement : 1
  CurrentHitPoint : 12
  MaxHitPoint : 12
  Strength : 1
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 4
}
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[2. 캐릭터 클래스 정의 프로토타입에 사용될 예제들은 페이지 마지막에 정리 Character { Race : type // 인간,드워프 Class : type // 전사, 성직자 Level : uint // 레벨 Movement : uint //이동 가능 칸수 CurrentHitPoint : uint //현재 HP MaxHitPoint : uint //최대 HP Strength : uint // 힘, 일단 1 AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스 AttackRange : uint //공격범위, 근거리일 경우는 1 ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11 WeaponType : type //한손 WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage) } 3. 두 캐릭터의 HP 표시하기 Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시 4. 커맨드 메뉴 구현하기 해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행 한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경 1. 이동 이동 메뉴를 선택시 이전페이지 와 동일하게 이동할 수 있는 영역이 표시됨 영역은 Character Class의 Movement 값을 적용하여 표시 영역 클릭시 해당 타일로 이동 2. 공격 영역은 Character Class의 AttackRange 값을 적용하여 표시 영역 클릭시 아래 공격 로직을 적용 3. 대기 따로 영역 필요없이 상대방에게 턴을 넘김 5. 공격 적용 이번에는 따로 무기없이 한손, 근거리 전투로만 한정 명중 굴림 공격이 성공하는지 체크하는 로직으로 공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공 Basic Fantasy - 조우의 공격하기 설명 참고 명중 굴림 성공 유무 수식 Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC 피해 명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영 Basic Fantasy - 조우의 피해 설명 참고 피해 산정 수식 피해 = Math.Rand(WeaponDamage) + Strength 상대편 HP 적용, 상대편 HPBar에 업데이트 CurrentHitPoint = CurrentHitPoint - 피해 공격턴 마무리 상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리 5. 프로토타입에 적용할 Chracter 예제 데이터 드워프/전사 Character { Race : Dwarf Class : Fighter Level : 1 Movement : 2 CurrentHitPoint : 15 MaxHitPoint : 15 Strength : 2 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 6 } 인간/성직자 Character { Race : Human Class : Cleric Level : 1 Movement : 1 CurrentHitPoint : 12 MaxHitPoint : 12 Strength : 1 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 4 }]]></summary></entry><entry><title type="html">Dotnetty Prototype Step3</title><link href="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step3" /><published>2023-10-12T00:00:00+09:00</published><updated>2023-10-12T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3</id><content type="html" xml:base="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html"><![CDATA[<h1 id="인스턴스-메신저-구현하기">인스턴스 메신저 구현하기</h1>
<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/InstantMessenger">github project</a></li>
  <li><a href="https://github.com/SoonPoong-Hong/hong-netty-messenger">Netty로 구현된 원래 프로젝트</a></li>
</ul>

<h2 id="기능-패킷-타입--enum-e_action-참고">기능 (패킷 타입) : enum E_ACTION 참고</h2>
<ul>
  <li>LOGIN  //로그인</li>
  <li>LOGOUT //로그아웃</li>
  <li>ENTER_TO_ROOM //방 입장 요청</li>
  <li>EXIT_FROM_ROOM //방 퇴장 요청</li>
  <li>TALK_MESSAGE //메시지 톡 전송</li>
  <li>ROOM_LIST //방 목록</li>
  <li>USER_LIST //방 사람들 목록</li>
  <li>RESPONSE_SUCCESS //성공 – 서버 응답으로 사용</li>
  <li>RESPONSE_FAIL //실패 – 서버 응답으로 사용</li>
</ul>

<h2 id="클라이언트-명령">클라이언트 명령</h2>
<ul>
  <li>LOGIN은 실행과 동시에 같이 처리됨으로 생략</li>
  <li>위의 패킷 타입과 동일</li>
</ul>

<h3 id="단일명령">단일명령</h3>
<ul>
  <li>끝에 :만 붙여서 처리</li>
  <li>LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST:</li>
</ul>

<h3 id="파라메터명령">파라메터명령</h3>
<ul>
  <li>: 뒤에 파라메터를 붙여 처리</li>
  <li>TALK_MESSAGE:<strong>전달할 메시지</strong></li>
  <li>ENTER_TO_ROOM:<strong>들아걸 방이름</strong></li>
</ul>

<h2 id="패킷-구조">패킷 구조</h2>
<ul>
  <li>
    <p>MessagePacket/PacketHelper 클래스 참조</p>
  </li>
  <li>Header
    <ul>
      <li>= 로 시작하고 = 로 끝남</li>
      <li>key:value로 선언되고, 각 라인은 CRLF 로 처리</li>
      <li>length:XXXX 는 Body의 길이, length가 0이면 contents가 없다.</li>
    </ul>
  </li>
  <li>Body
    <ul>
      <li>문자열로 이루어진 데이터</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>
<ul>
  <li>LOGIN 패킷의 경우 : Body가 없음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
LOGIN
length:0
refId:1
refName:nick
=
</code></pre></div>    </div>
  </li>
  <li>USER_LIST 패킷의 경우
    <ul>
      <li>[“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다.
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
USER_LIST
length:5
=
["1"]
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="pipeline-설명--클라-서버-클라">Pipeline 설명 : 클라-&gt;서버-&gt;클라</h2>
<ul>
  <li>클라 전송
    <ol>
      <li>부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화)</li>
      <li>Connect</li>
      <li>ClientConsoleInput 클래스에서 유저 입력을 받음</li>
      <li>bootstrap channel의 WriteAndFlushAsync 메소드 호출</li>
      <li>MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨</li>
    </ol>
  </li>
  <li>서버 수신
    <ol>
      <li>MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성</li>
      <li>MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리</li>
      <li>그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨</li>
      <li>처리된 결과를 <strong>클라 전송 4/5 항목과 동일하게 실행</strong>하여 전송</li>
    </ol>
  </li>
</ul>

<h2 id="서버클라이언트-콘솔-실행">서버/클라이언트 콘솔 실행</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-im-server-client.png" alt="서버-클라이언트 콘솔" /></li>
</ul>

<h3 id="서버-실행">서버 실행</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMServer
</code></pre></div></div>

<h3 id="클라-실행">클라 실행</h3>
<ul>
  <li>./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 1 nick
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 2 choi
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><category term="InstantMessenger" /><summary type="html"><![CDATA[인스턴스 메신저 구현하기 소스코드 github project Netty로 구현된 원래 프로젝트 기능 (패킷 타입) : enum E_ACTION 참고 LOGIN //로그인 LOGOUT //로그아웃 ENTER_TO_ROOM //방 입장 요청 EXIT_FROM_ROOM //방 퇴장 요청 TALK_MESSAGE //메시지 톡 전송 ROOM_LIST //방 목록 USER_LIST //방 사람들 목록 RESPONSE_SUCCESS //성공 – 서버 응답으로 사용 RESPONSE_FAIL //실패 – 서버 응답으로 사용 클라이언트 명령 LOGIN은 실행과 동시에 같이 처리됨으로 생략 위의 패킷 타입과 동일 단일명령 끝에 :만 붙여서 처리 LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST: 파라메터명령 : 뒤에 파라메터를 붙여 처리 TALK_MESSAGE:전달할 메시지 ENTER_TO_ROOM:들아걸 방이름 패킷 구조 MessagePacket/PacketHelper 클래스 참조 Header = 로 시작하고 = 로 끝남 key:value로 선언되고, 각 라인은 CRLF 로 처리 length:XXXX 는 Body의 길이, length가 0이면 contents가 없다. Body 문자열로 이루어진 데이터 예시 LOGIN 패킷의 경우 : Body가 없음 = LOGIN length:0 refId:1 refName:nick = USER_LIST 패킷의 경우 [“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다. = USER_LIST length:5 = ["1"] Pipeline 설명 : 클라-&gt;서버-&gt;클라 클라 전송 부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화) Connect ClientConsoleInput 클래스에서 유저 입력을 받음 bootstrap channel의 WriteAndFlushAsync 메소드 호출 MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨 서버 수신 MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성 MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리 그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨 처리된 결과를 클라 전송 4/5 항목과 동일하게 실행하여 전송 서버/클라이언트 콘솔 실행 서버 실행 &gt; ./IMServer 클라 실행 ./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨 &gt; ./IMClient 1 nick &gt; ./IMClient 2 choi]]></summary></entry><entry><title type="html">Dotnetty Prototype Step2</title><link href="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step2" /><published>2023-10-05T00:00:00+09:00</published><updated>2023-10-05T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2%20copy</id><content type="html" xml:base="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html"><![CDATA[<h1 id="채팅-프로그램으로-오델로-게임-구현하기">채팅 프로그램으로 오델로 게임 구현하기</h1>
<ul>
  <li><a href="/dotnetty-server-prototype-step1">채팅 구현</a>의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현</li>
  <li>채팅과 동일하게 서버 한대와 클라이언트 두대로 구성</li>
</ul>

<h2 id="게임-규칙">게임 규칙</h2>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/오델로#규칙">오델로#규칙</a> 참조</li>
  <li>첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현)</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/Othello">github project</a></li>
  <li>프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중</li>
</ul>

<h2 id="구현규칙">구현규칙</h2>
<h3 id="패킷">패킷</h3>
<ul>
  <li>채팅에서 사용한 StringEncoder/StringDecoder를 사용</li>
  <li>포멧
    <ul>
      <li><strong>CommandKey</strong>::<strong>CommandValue</strong></li>
      <li>예) Put::5,4 // 5,4에 돌을 놓아둡니다.</li>
    </ul>
  </li>
</ul>

<h4 id="commandkey">CommandKey</h4>
<h5 id="client--유저가-내릴-수-있는-명령">Client : 유저가 내릴 수 있는 명령</h5>
<ul>
  <li><em>Join</em> : <em>자동 명령</em>, 닉네임 입력하면 자동으로 서버에 등록됩니다.</li>
  <li>Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다.</li>
  <li>Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다.</li>
</ul>

<h5 id="server--서버에서-판단하여-전파하는-명령">Server : 서버에서 판단하여 전파하는 명령</h5>
<ul>
  <li>CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령</li>
  <li>StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령</li>
  <li>TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령</li>
  <li>Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령</li>
  <li>Members : 현재 접속한 구성원들을 알려주는 명령</li>
  <li>FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨</li>
  <li>SuccessPut : Put 명령이 문제없이 실행되었을 때 응답</li>
  <li>FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력</li>
  <li>NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송</li>
</ul>

<h3 id="클라이언트">클라이언트</h3>
<ul>
  <li>소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs</li>
</ul>

<ol>
  <li>클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함</li>
  <li>입력받은 내용을 패킷을 통해 모두 서버로 전송</li>
  <li>즉, 클라이언트에서는 판단하는 로직이 없음</li>
</ol>

<h3 id="서버">서버</h3>
<ul>
  <li>소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs</li>
</ul>

<ol>
  <li>서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한</li>
  <li>각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행</li>
  <li>그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작</li>
</ol>

<h2 id="구현중-발견된-문제점">구현중 발견된 문제점</h2>
<ul>
  <li>패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생
    <ul>
      <li>다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인  <strong>|</strong> 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리
        <ul>
          <li>처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ]
            <ol>
              <li>SuccessPut 처리</li>
              <li>FlipTiles 처리</li>
              <li>NextTurn 처리</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡
    <ul>
      <li>여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용)</li>
    </ul>
  </li>
  <li>클라이언트 콘솔 문제
    <ul>
      <li>오델로 판을 파악하기 어려움</li>
    </ul>
  </li>
</ul>

<h2 id="오델로-서버클라이언트-콘솔화면">오델로 서버/클라이언트 콘솔화면</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-step2-othello.png" alt="서버-클라이언트 오델로 콘솔" /></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><summary type="html"><![CDATA[채팅 프로그램으로 오델로 게임 구현하기 채팅 구현의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현 채팅과 동일하게 서버 한대와 클라이언트 두대로 구성 게임 규칙 오델로#규칙 참조 첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현) 소스코드 github project 프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중 구현규칙 패킷 채팅에서 사용한 StringEncoder/StringDecoder를 사용 포멧 CommandKey::CommandValue 예) Put::5,4 // 5,4에 돌을 놓아둡니다. CommandKey Client : 유저가 내릴 수 있는 명령 Join : 자동 명령, 닉네임 입력하면 자동으로 서버에 등록됩니다. Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다. Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다. Server : 서버에서 판단하여 전파하는 명령 CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령 StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령 TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령 Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령 Members : 현재 접속한 구성원들을 알려주는 명령 FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨 SuccessPut : Put 명령이 문제없이 실행되었을 때 응답 FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력 NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송 클라이언트 소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs 클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함 입력받은 내용을 패킷을 통해 모두 서버로 전송 즉, 클라이언트에서는 판단하는 로직이 없음 서버 소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs 서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한 각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행 그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작 구현중 발견된 문제점 패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생 다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인 | 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리 처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ] SuccessPut 처리 FlipTiles 처리 NextTurn 처리 위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡 여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용) 클라이언트 콘솔 문제 오델로 판을 파악하기 어려움 오델로 서버/클라이언트 콘솔화면]]></summary></entry><entry><title type="html">Unity Prototype Step1</title><link href="http://localhost:4000/unity-prototype-step1" rel="alternate" type="text/html" title="Unity Prototype Step1" /><published>2023-09-27T00:00:00+09:00</published><updated>2023-09-27T00:00:00+09:00</updated><id>http://localhost:4000/15-unity-client-step1</id><content type="html" xml:base="http://localhost:4000/unity-prototype-step1"><![CDATA[<h1 id="1-두-캐릭터를-그리드-안에서-이동하기">1. 두 캐릭터를 그리드 안에서 이동하기</h1>
<ul>
  <li>10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기</li>
  <li>단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step1-movement.png" alt="캐릭터 이동" /></p>

<h2 id="데이터">데이터</h2>
<ul>
  <li>드워프/전사 : 가로,세로 2칸씩 이동(파란색)</li>
  <li>인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색)</li>
</ul>

<h2 id="플로우">플로우</h2>
<ol>
  <li>드워프 선택됨</li>
  <li>해당 드워프의 이동 가능 거리가 표시</li>
  <li>이동가능한 그리드를 선택하면 드워프 이동</li>
  <li>성직자 선택됨</li>
  <li>2,3 동일하게 반복</li>
  <li>1부터 다시 시작</li>
</ol>

<h2 id="데이터구조">데이터구조</h2>
<ul>
  <li>2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것.</li>
  <li>즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서)</li>
</ul>

<h2 id="나중에">나중에…</h2>
<ul>
  <li><a href="/2023/09/25/10-basic-fantasy-pregenerated-characters.html">미리 생성된 캐릭터들</a> 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[1. 두 캐릭터를 그리드 안에서 이동하기 10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기 단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨 데이터 드워프/전사 : 가로,세로 2칸씩 이동(파란색) 인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색) 플로우 드워프 선택됨 해당 드워프의 이동 가능 거리가 표시 이동가능한 그리드를 선택하면 드워프 이동 성직자 선택됨 2,3 동일하게 반복 1부터 다시 시작 데이터구조 2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것. 즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서) 나중에… 미리 생성된 캐릭터들 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획]]></summary></entry><entry><title type="html">Dotnetty Prototype Step1</title><link href="http://localhost:4000/dotnetty-server-prototype-step1" rel="alternate" type="text/html" title="Dotnetty Prototype Step1" /><published>2023-09-27T00:00:00+09:00</published><updated>2023-09-27T00:00:00+09:00</updated><id>http://localhost:4000/16-dotnetty-server-prototype-step1</id><content type="html" xml:base="http://localhost:4000/dotnetty-server-prototype-step1"><![CDATA[<h1 id="세상에서-가장-간단한-채팅-서버클라이언트-구현하기">세상에서 가장 간단한 채팅 서버/클라이언트 구현하기</h1>
<ul>
  <li>참고 문서 : <a href="https://itsallbinary.com/netty-project-understanding-netty-using-simple-real-world-example-of-chat-server-client-good-for-beginners/">Understanding Netty using simple real-world example of Chat server client</a>
    <ul>
      <li>Java 이지만 C#으로 포팅진행합니다.</li>
    </ul>
  </li>
  <li>Bootstrap 이란? : <a href="https://namu.wiki/w/Bootstrap">나무위키 참고</a>
    <ul>
      <li>일반적으로 한 번 시작되면 알아서 진행되는 일련의 과정</li>
    </ul>
  </li>
</ul>

<h2 id="네티-구성요소">네티 구성요소</h2>
<p>간단하고 높은 수준에서 Netty 서버 또는 클라이언트에는 이러한 기본 클래스가 필요합니다.</p>
<ul>
  <li><strong>Program</strong> – 이 클래스는 서버 또는 클라이언트를 부트스트랩합니다. 서버의 경우 지정된 Host/Port에서 서버를 시작합니다. 클라이언트의 경우 제공된 서버에 연결하여 연결을 생성합니다.</li>
  <li><strong>Channel Handler</strong> – 채널 핸들러는 채널 활성, 채널 읽기 또는 예외 발생 등과 같은 다양한 이벤트를 처리합니다.</li>
</ul>

<h2 id="dotnetty를-이용한-채팅-서버-클라이언트-애플리케이션">DotNetty를 이용한 채팅 서버-클라이언트 애플리케이션</h2>
<ol>
  <li>콘솔 입력 기반 채팅 클라이언트 애플리케이션을 만듭니다.</li>
  <li>클라이언트를 시작할 때 우리는 그의 이름을 묻고 그 후에 다른 클라이언트에게 보낼 채팅 메시지를 받습니다.</li>
  <li>채팅 서버에 이름 및 채팅 메시지를 보냅니다.</li>
  <li>그러면 채팅 서버는 보낸 사람의 이름과 함께 해당 메시지를 모든 클라이언트에 게시합니다.</li>
</ol>

<p>다음은 서버와 클라이언트의 구성 요소를 보여주는 다이어그램입니다. 아래 다이어그램은 한 클라이언트에서 다른 클라이언트로의 채팅 메시지 “Hello”의 통신 경로도 추적합니다.
<img src="/assets/images/prototype/prototype-dotnetty-chat-server-client.jpeg" alt="서버-클라이언트 채팅" /></p>

<h2 id="코딩하기">코딩하기</h2>
<ul>
  <li><strong>종속성</strong> – DotNetty 서버 클라이언트 프레임워크를 사용하려면 다음과 같은 package가 필요합니다.
    <ul>
      <li>DotNetty.Common</li>
      <li>DotNetty.Codecs</li>
      <li>DotNetty.Handlers</li>
      <li>DotNetty.Transport</li>
    </ul>
  </li>
</ul>

<h2 id="bootstrapping-네티">Bootstrapping 네티</h2>
<ul>
  <li><strong>ServerBootstrap</strong> – 서버 채널을 부트스트랩하고 서버를 시작하는 코드입니다. 연결을 수신할 포트에 서버를 바인딩합니다.</li>
  <li><strong>Bootstrap</strong> – 클라이언트 채널을 부트스트랩하는 코드입니다.</li>
  <li><strong>EventLoopGroup</strong>
    <ul>
      <li>EventLoop들의 그룹입니다. EventLoop는 등록된 채널에 대한 모든 I/O 작업을 처리합니다.</li>
      <li>ServerBootstrap에는 두 가지 유형의 EventLoopGroup, 즉 “boss”와 “worker”가 필요합니다. 클라이언트 boostrap에는 보스 그룹이 필요하지 않습니다.</li>
      <li>Boss EventLoopGroup – 이 EventLoop 그룹은 들어오는 연결(connection)을 수락(accept)하고 등록(register)합니다.</li>
      <li>Worker EventLoopGroup – Boss가 연결을 수락하고 이를 Worker EventLoopGroup에 등록합니다. Worker는 해당 연결을 통해 통신하는 동안 모든 이벤트를 처리합니다.</li>
    </ul>
  </li>
  <li>채널 <strong>TcpServerSocketChannel</strong> – Tcp Socket을 이용하여 새 연결을 허용하도록 서버를 구성합니다. 클라이언트의 경우 TcpSocketChannel을 이용합니다.</li>
  <li><strong>Decoder/Encoder(StringDecoder / StringEncoder)</strong>
    <ul>
      <li>Netty 통신은 Byte 형식의 네트워크 소켓 채널을 통해 발생합니다. 따라서 특정 데이터형을 전송하려는 경우 데이터형을 Byte로 인코딩하는 인코더와 Byte를 데이터형로 디코딩하는 인코더를 제공합니다.</li>
      <li>StringDecoder, StringEncoder는 Netty에서 제공됩니다. 하지만 필요한 모든 데이터 유형에 대해 자체 인코더나 디코더를 만들 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples">github project</a></li>
</ul>

<h2 id="테스트-콘솔화면">테스트 콘솔화면</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-chat-server-client-sample.png" alt="서버-클라이언트 콘솔" /></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><summary type="html"><![CDATA[세상에서 가장 간단한 채팅 서버/클라이언트 구현하기 참고 문서 : Understanding Netty using simple real-world example of Chat server client Java 이지만 C#으로 포팅진행합니다. Bootstrap 이란? : 나무위키 참고 일반적으로 한 번 시작되면 알아서 진행되는 일련의 과정 네티 구성요소 간단하고 높은 수준에서 Netty 서버 또는 클라이언트에는 이러한 기본 클래스가 필요합니다. Program – 이 클래스는 서버 또는 클라이언트를 부트스트랩합니다. 서버의 경우 지정된 Host/Port에서 서버를 시작합니다. 클라이언트의 경우 제공된 서버에 연결하여 연결을 생성합니다. Channel Handler – 채널 핸들러는 채널 활성, 채널 읽기 또는 예외 발생 등과 같은 다양한 이벤트를 처리합니다. DotNetty를 이용한 채팅 서버-클라이언트 애플리케이션 콘솔 입력 기반 채팅 클라이언트 애플리케이션을 만듭니다. 클라이언트를 시작할 때 우리는 그의 이름을 묻고 그 후에 다른 클라이언트에게 보낼 채팅 메시지를 받습니다. 채팅 서버에 이름 및 채팅 메시지를 보냅니다. 그러면 채팅 서버는 보낸 사람의 이름과 함께 해당 메시지를 모든 클라이언트에 게시합니다. 다음은 서버와 클라이언트의 구성 요소를 보여주는 다이어그램입니다. 아래 다이어그램은 한 클라이언트에서 다른 클라이언트로의 채팅 메시지 “Hello”의 통신 경로도 추적합니다. 코딩하기 종속성 – DotNetty 서버 클라이언트 프레임워크를 사용하려면 다음과 같은 package가 필요합니다. DotNetty.Common DotNetty.Codecs DotNetty.Handlers DotNetty.Transport Bootstrapping 네티 ServerBootstrap – 서버 채널을 부트스트랩하고 서버를 시작하는 코드입니다. 연결을 수신할 포트에 서버를 바인딩합니다. Bootstrap – 클라이언트 채널을 부트스트랩하는 코드입니다. EventLoopGroup EventLoop들의 그룹입니다. EventLoop는 등록된 채널에 대한 모든 I/O 작업을 처리합니다. ServerBootstrap에는 두 가지 유형의 EventLoopGroup, 즉 “boss”와 “worker”가 필요합니다. 클라이언트 boostrap에는 보스 그룹이 필요하지 않습니다. Boss EventLoopGroup – 이 EventLoop 그룹은 들어오는 연결(connection)을 수락(accept)하고 등록(register)합니다. Worker EventLoopGroup – Boss가 연결을 수락하고 이를 Worker EventLoopGroup에 등록합니다. Worker는 해당 연결을 통해 통신하는 동안 모든 이벤트를 처리합니다. 채널 TcpServerSocketChannel – Tcp Socket을 이용하여 새 연결을 허용하도록 서버를 구성합니다. 클라이언트의 경우 TcpSocketChannel을 이용합니다. Decoder/Encoder(StringDecoder / StringEncoder) Netty 통신은 Byte 형식의 네트워크 소켓 채널을 통해 발생합니다. 따라서 특정 데이터형을 전송하려는 경우 데이터형을 Byte로 인코딩하는 인코더와 Byte를 데이터형로 디코딩하는 인코더를 제공합니다. StringDecoder, StringEncoder는 Netty에서 제공됩니다. 하지만 필요한 모든 데이터 유형에 대해 자체 인코더나 디코더를 만들 수 있습니다. 소스코드 github project 테스트 콘솔화면]]></summary></entry><entry><title type="html">Basic Fantasy - 미리 생성된 캐릭터들</title><link href="http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters.html" rel="alternate" type="text/html" title="Basic Fantasy - 미리 생성된 캐릭터들" /><published>2023-09-25T00:00:00+09:00</published><updated>2023-09-25T00:00:00+09:00</updated><id>http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters</id><content type="html" xml:base="http://localhost:4000/2023/09/25/10-basic-fantasy-pregenerated-characters.html"><![CDATA[<ul>
  <li>미리 생성된 캐릭터 데이터 시트</li>
</ul>

<p><a href="/assets/files/characters.xlsx">캐릭터 데이터 데이터</a></p>]]></content><author><name>nickchoi</name></author><category term="BasicFantasy" /><category term="Rule" /><category term="참고자료" /><summary type="html"><![CDATA[미리 생성된 캐릭터 데이터 시트 캐릭터 데이터 데이터]]></summary></entry></feed>