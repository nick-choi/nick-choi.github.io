<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-27T00:54:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nick Choi’s Works</title><subtitle>Nick Choi&apos;s Works
</subtitle><author><name>nickchoi</name></author><entry><title type="html">More Modern CMake - Variables explained</title><link href="http://localhost:4000/more-modern-cmake-variables-explained" rel="alternate" type="text/html" title="More Modern CMake - Variables explained" /><published>2024-01-27T00:00:00+09:00</published><updated>2024-01-27T00:00:00+09:00</updated><id>http://localhost:4000/00-more-modern-cmake-variables-explained</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-variables-explained"><![CDATA[<h1 id="variables-explained">Variables explained</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>How do variables work?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>Learn about local variables.</li>
      <li>Understand that cached variables persist across runs.</li>
      <li>Know how to glob, and why you might not do it.</li>
    </ul>
  </li>
</ul>

<h2 id="variables">Variables</h2>

<p>For this exercise, we will just directly run a CMake Script, instead of running <strong>CMakeLists.txt</strong>. The command to do so is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Assuming you have a file called example.cmake:
cmake -P example.cmake
</code></pre></div></div>
<p>This way, we don’t have so many little builds sitting around.</p>

<h3 id="local-variables">Local variables</h3>

<p>Let’s start with a local variable.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># local.cmake
set(MY_VARIABLE "I am a variable")
message(STATUS "${MY_VARIABLE}")
</code></pre></div></div>
<p>Here we see the set command, which sets a variable, and the message command, which prints out a string. We are printing a STATUS message - there are other types (many other types in CMake 3.15+).</p>

<h4 id="more-about-variables">More about variables</h4>

<p>Try the following:</p>
<ul>
  <li>Remove the quotes in set. What happens?</li>
  <li>Remove the quotes in message. What happens? Why?</li>
  <li>Try setting a cached variable using -DMY_VARIABLE=something before the -P. Which variable is shown?</li>
</ul>

<h3 id="cached-variables">Cached variables</h3>

<p>Now, let’s look at cached variables; a key ingredient in all CMake builds. In a build, cached variables are set in the command line or in a graphical tool (such as <strong>ccmake</strong>, <strong>cmake-gui</strong>), and then written to a file called <strong>CMakeCache.txt</strong>. When you rerun, the cache is read in before starting, so that CMake “remembers” what you ran it with. For our example, we will use CMake in script mode, and that will not write out a cache, which makes it easier to play with. Feel free to look back at the example you built in the last lesson and investigate the <strong>CMakeCache.txt</strong> file in your build directory there. Things like the compiler location, as discovered or set on the first run, are cached.</p>

<p>Here’s what a cached variable looks like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cache.cmake
set(MY_CACHE_VAR "I am a cached variable" CACHE STRING "Description")
message(STATUS "${MY_CACHE_VAR}")
</code></pre></div></div>
<p>We have to include the variable type here, which we didn’t have to do before (but we could have) - it helps graphical CMake tools show the correct options. The main difference is the <strong>CACHE</strong> keyword and the description. If you were to run <strong>cmake -L</strong> or <strong>cmake -LH</strong>, you would see all the cached variables and descriptions.</p>

<p>The normal set command only sets the cached variable if it is not already set - this allows you to override cached variables with <strong>-D</strong>. Try:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake -DMY_CACHE_VAR="command line" -P cache.cmake
</code></pre></div></div>
<p>You can use <strong>FORCE</strong> to set a cached variable even if it already set; this should not be very common. Since cached variables are global, sometimes they get used as a makeshift global variable - the keyword <strong>INTERNAL</strong> is identical to <strong>STRING FORCE</strong>, and hides the variable from listings/GUIs.</p>

<p>Since bool cached variables are so common for builds, there is a shortcut syntax for making one using <strong>option</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>option(MY_OPTION "On or off" OFF)
</code></pre></div></div>

<h3 id="other-variables">Other variables</h3>

<p>You can get environment variables with $ENV{name}. You can check to see if an environment variable is defined with if(DEFINED ENV{name}) (notice the missing $).</p>

<p>Properties are a form of variable that is attached to a target; you can use get_property and set_property, or [get_target_properties][] and set_target_properties (stylistic preference) to access and set these. You can see a list of all properties by CMake version; there is no way to get this programmatically.</p>

<h4 id="handy-tip">Handy tip</h4>

<p>Use include(CMakePrintHelpers) to add the useful commands cmake_print_properties and cmake_print_variables to save yourself some typing when debugging variables and properties.</p>

<h3 id="target-properties-and-variables">Target properties and variables</h3>

<p>You have seen targets; they have properties attached that control their behavior. Many of these properties, such as CXX_EXTENSIONS, have a matching variable that starts with CMAKE_, such as CMAKE_CXX_EXTENSIONS, that will be used to initialize them. So you can using set property on each target by setting a variable before making the targets.</p>

<h3 id="globbing">Globbing</h3>

<p>There are several commands that help with strings, files, [lists][], and the like. Let’s take a quick look at one of the most interesting: glob.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file(GLOB OUTPUT_VAR *.cxx)
</code></pre></div></div>

<p>This will make a list of all files that match the pattern and put it into OUTPUT_VAR. You can also use GLOB_RECURSE, which will recurse subdirectories. There are several useful options, which you can look at in the documentation, but one is particularly important: CONFIGURE_DEPENDS (CMake 3.12+).</p>

<p>When you rerun the build step (not the configure step), then unless you setCONFIGURE_DEPENDS, your build tool will not check to see if you have added any new files that now pass the glob. This is the reason poorly written CMake projects often have issues when you are trying to add files; some people are in the habit of rerunning cmake before every build because of this. You shouldn’t ever have to manually reconfigure; the build tool will rerun CMake as needed with this one exception. If you add CONFIGURE_DEPENDS, then most build tools will actually start checking glob too. The classic rule of CMake was “never glob”; the new rule is “never glob, but if you have to, add CONFIGURE_DEPENDS”.</p>

<h3 id="더-읽어보기">더 읽어보기</h3>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/chapters/basics/variables.html">Modern CMake basics/variables</a>을 기반으로 함</li>
  <li><a href="https://cmake.org/cmake/help/latest/index.html">CMake’s docs</a>도 읽어볼 것</li>
</ul>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>Local variables work in this directory or below.</li>
  <li>Cached variables are stored between runs.</li>
  <li>You can access environment variables, properties, and more.</li>
  <li>You can glob to collect files from disk, but it might not always be a good idea.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Variables explained Overview 질문 How do variables work? 목표 Learn about local variables. Understand that cached variables persist across runs. Know how to glob, and why you might not do it. Variables For this exercise, we will just directly run a CMake Script, instead of running CMakeLists.txt. The command to do so is: # Assuming you have a file called example.cmake: cmake -P example.cmake This way, we don’t have so many little builds sitting around. Local variables Let’s start with a local variable. # local.cmake set(MY_VARIABLE "I am a variable") message(STATUS "${MY_VARIABLE}") Here we see the set command, which sets a variable, and the message command, which prints out a string. We are printing a STATUS message - there are other types (many other types in CMake 3.15+). More about variables Try the following: Remove the quotes in set. What happens? Remove the quotes in message. What happens? Why? Try setting a cached variable using -DMY_VARIABLE=something before the -P. Which variable is shown? Cached variables Now, let’s look at cached variables; a key ingredient in all CMake builds. In a build, cached variables are set in the command line or in a graphical tool (such as ccmake, cmake-gui), and then written to a file called CMakeCache.txt. When you rerun, the cache is read in before starting, so that CMake “remembers” what you ran it with. For our example, we will use CMake in script mode, and that will not write out a cache, which makes it easier to play with. Feel free to look back at the example you built in the last lesson and investigate the CMakeCache.txt file in your build directory there. Things like the compiler location, as discovered or set on the first run, are cached. Here’s what a cached variable looks like: # cache.cmake set(MY_CACHE_VAR "I am a cached variable" CACHE STRING "Description") message(STATUS "${MY_CACHE_VAR}") We have to include the variable type here, which we didn’t have to do before (but we could have) - it helps graphical CMake tools show the correct options. The main difference is the CACHE keyword and the description. If you were to run cmake -L or cmake -LH, you would see all the cached variables and descriptions. The normal set command only sets the cached variable if it is not already set - this allows you to override cached variables with -D. Try: cmake -DMY_CACHE_VAR="command line" -P cache.cmake You can use FORCE to set a cached variable even if it already set; this should not be very common. Since cached variables are global, sometimes they get used as a makeshift global variable - the keyword INTERNAL is identical to STRING FORCE, and hides the variable from listings/GUIs. Since bool cached variables are so common for builds, there is a shortcut syntax for making one using option: option(MY_OPTION "On or off" OFF) Other variables You can get environment variables with $ENV{name}. You can check to see if an environment variable is defined with if(DEFINED ENV{name}) (notice the missing $). Properties are a form of variable that is attached to a target; you can use get_property and set_property, or [get_target_properties][] and set_target_properties (stylistic preference) to access and set these. You can see a list of all properties by CMake version; there is no way to get this programmatically. Handy tip Use include(CMakePrintHelpers) to add the useful commands cmake_print_properties and cmake_print_variables to save yourself some typing when debugging variables and properties. Target properties and variables You have seen targets; they have properties attached that control their behavior. Many of these properties, such as CXX_EXTENSIONS, have a matching variable that starts with CMAKE_, such as CMAKE_CXX_EXTENSIONS, that will be used to initialize them. So you can using set property on each target by setting a variable before making the targets. Globbing There are several commands that help with strings, files, [lists][], and the like. Let’s take a quick look at one of the most interesting: glob. file(GLOB OUTPUT_VAR *.cxx) This will make a list of all files that match the pattern and put it into OUTPUT_VAR. You can also use GLOB_RECURSE, which will recurse subdirectories. There are several useful options, which you can look at in the documentation, but one is particularly important: CONFIGURE_DEPENDS (CMake 3.12+). When you rerun the build step (not the configure step), then unless you setCONFIGURE_DEPENDS, your build tool will not check to see if you have added any new files that now pass the glob. This is the reason poorly written CMake projects often have issues when you are trying to add files; some people are in the habit of rerunning cmake before every build because of this. You shouldn’t ever have to manually reconfigure; the build tool will rerun CMake as needed with this one exception. If you add CONFIGURE_DEPENDS, then most build tools will actually start checking glob too. The classic rule of CMake was “never glob”; the new rule is “never glob, but if you have to, add CONFIGURE_DEPENDS”. 더 읽어보기 Modern CMake basics/variables을 기반으로 함 CMake’s docs도 읽어볼 것 핵심사항 Local variables work in this directory or below. Cached variables are stored between runs. You can access environment variables, properties, and more. You can glob to collect files from disk, but it might not always be a good idea.]]></summary></entry><entry><title type="html">More Modern CMake - Working with Targets</title><link href="http://localhost:4000/more-modern-cmake-working-with-targets" rel="alternate" type="text/html" title="More Modern CMake - Working with Targets" /><published>2024-01-22T00:00:00+09:00</published><updated>2024-01-22T00:00:00+09:00</updated><id>http://localhost:4000/20-more-modern-cmake-working-with-targets</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-working-with-targets"><![CDATA[<h1 id="working-with-targets">Working with Targets</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>타겟(target)은 어떻게 동작하는가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>타겟(target) 설정 방법을 알아두자</li>
      <li>linking 및 INTERFACE 속성 이해하자</li>
      <li>INTERFACE 타겟(target) 만들기</li>
    </ul>
  </li>
</ul>

<h2 id="타겟targets">타겟(Targets)</h2>

<p>이제 CMake의 세 라인을 사용하여 단일 파일을 컴파일하는 방법을 알게 되었다. 하지만 종속성이 있는 파일이 두 개 이상 있으면 어떻게 될까? 프로젝트 구조에 대해 CMake에 알릴 수 있어야 하며 이는 프로젝트를 빌드하는 데 도움이 된다. 그러기 위해서는 target이 필요한다.</p>

<p>넌 이 타겟(target)은 이미 보았다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_executable(myexample simple.cpp)
</code></pre></div></div>

<p>그러면 <strong>myexample</strong> 이름으로 “실행 가능한” 타겟이 만들어진다. 타겟 이름은 고유해야 한다(실제로 원하는 경우 실행 파일 이름을 타겟 이름이 아닌 다른 이름으로 설정할 수 있는 방법이 있다).</p>

<p>타겟은 다른 언어의 “객체(object)”와 매우 유사하며, 정보를 저장하고 있는 속성(멤버 변수)를 가지고 있다. 예를 들어 <strong>SOURCES</strong> 속성에는 <strong>simple.cpp</strong>가 있다.</p>

<p>또 다른 유형의 타겟 은 라이브러리(library)이다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_library(mylibrary simplelib.cpp)
</code></pre></div></div>

<p>어떤 종류의 라이브러리를 만들고 싶은지 알고 있다면, 키워드 <strong>STATIC</strong>, <strong>SHARED</strong> 또는 <strong>MODULE</strong>을 추가할 수 있다. 기본값은 <strong>BUILD_SHARED_LIBS</strong>를 사용하여 사용자가 선택할 수 있는 일종의 “자동(auto)” 라이브러리이다.</p>

<p>빌드되지 않은 라이브러리도 만들 수 있다. 이에 대한 자세한 내용은 나중에 타겟으로 무엇을 할 수 있는지 살펴본다.</p>

<h2 id="링킹연길">링킹(연길)</h2>

<p>여러 타겟이 있으면 <strong>target_link_libraries</strong> 및 키워드를 사용하여 타겟 간의 관계를 설명할 수 있다. <strong>PUBLIC</strong>, <strong>PRIVATE</strong>, <strong>INTERFACE</strong> 중 하나이다. 라이브러리를 만들 때 이 키워드를 잊으면 안된다! CMake는 일반적으로 문제를 일으키는 이 타겟에 대해 이전 호환성 모드로 전환된다.</p>

<h3 id="질문">질문</h3>

<p><strong>my_lib.hpp</strong> 및 <strong>my_lib.cpp</strong>로 만든 <strong>my_lib</strong> 라이브러리가 있다. 컴파일하려면 최소한 C++14가 필요하다. 그런 다음 <strong>my_exe</strong>를 추가하고 <strong>my_lib</strong>가 필요한 경우 <strong>my_exe</strong>를 C++14 이상으로 컴파일해야 할까?</p>

<h3 id="정답">정답</h3>

<p>이는 헤더에 따라 다르다. 헤더에 C++14가 포함된 경우, 이는 PUBLIC 요구 사항이다. 라이브러리와 사용자 모두에게 필요하다. 그러나 헤더가 모든 C++ 버전에서 유효하고 <strong>my_lib.cpp</strong> 내부 구현에만 C++14가 필요한 경우 이는 <strong>PRIVATE</strong> 요구 사항이다.</p>

<ul>
  <li>사용자는 강제로 C++14 모드로 들어갈 필요가 없다.</li>
</ul>

<p>사용자에게 C++14가 필요하지만 라이브러리는 모든 C++ 버전으로 컴파일할 수 있다. 이는 INTERFACE 요구 사항이다.</p>

<p><img src="/assets/images/modern-cmake/linking.png" alt="링킹" /></p>

<p>그림 1: PUBLIC, PRIVATE 및 INTERFACE의 예. <strong>myprogram</strong>은 <strong>mylibrary</strong>를 통해 볼 수 있는 세 개의 라이브러리를 구축한다. Private 라이브러리는 영향을 미치지 않는다.</p>

<p>모든 타겟에는 값으로 채워질 수 있는 두 가지 속성 모음이 있다. “PRIVATE” 속성은 해당 대상을 빌드할 때 발생하는 작업을 제어하고, “INTERFACE” 속성은 이 타겟에 연결된 타겟에게 빌드 시 수행할 작업을 알려준다. <strong>PUBLIC</strong> 키워드는 두 속성 필드를 동시에 채운다.</p>

<h2 id="example-1-디렉토리-포함하기">Example 1: 디렉토리 포함하기</h2>

<p><strong>target_include_directories(TargetA PRIVATE mydir)</strong>를 실행하면 <strong>TargetA</strong>의 <strong>INCLUDE_DIRECTORIES</strong> 속성에 mydir이 추가된다. 대신 <strong>INTERFACE</strong> 키워드를 사용하면 <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>가 대신 추가되며  <strong>PUBLIC</strong>을 사용하는 경우 두 속성이 동시에 추가된다.</p>

<h2 id="example-2-c-standard">Example 2: C++ standard</h2>

<p>C++ 표준 속성인 <strong>CXX_STANDARD</strong>가 있다. 이 속성을 설정할 수 있으며 CMake의 많은 속성과 마찬가지로 설정된 경우 <strong>CMAKE_CXX_STANDARD</strong> 변수에서 기본값을 가져오지만 INTERFACE 버전이 없다. 타겟을 통해 <strong>CXX_STANDARD</strong>를 강제할 수 없다. C++11 인터페이스 타겟과 C++14 인터페이스 타겟이 있고 둘 다에 연결되어 있다면 어떻게 해야할까?</p>

<p>그런데 이를 처리하는 방법이 있다. 타겟을 컴파일하는 데 필요한 최소 컴파일 기능을 지정할 수 있다. <strong>cxx_std_11</strong> 및 유사한 메타 기능은 이에 적합하다. <strong>CXX_STANDARD</strong>가 설정되지 않는 한 타겟은 최소한 지정된 최고 레벨로 컴파일됩니다(그리고 <strong>CXX_STANDARD</strong>를 너무 낮게 설정하면 이는 훌륭하고 명확한 오류이다). <strong>target_compile_features</strong>는 예제 1의 디렉터리와 마찬가지로 <strong>COMPILE_FEATURES</strong> 및 <strong>INTERFACE_COMPILE_FEATURES</strong>를 채울 수 있다.</p>

<h3 id="시도해보기">시도해보기</h3>

<p>이 저장소를 가져와 예제로 이동해보라. 올바르게 빌드되는 CMakeList를 작성해 보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git
cd hsf-training-cmake-webpage/code/01-simple
</code></pre></div></div>

<p>여기에 있는 파일은 다음과 같다.</p>

<ul>
  <li>simple_lib.cpp: <strong>MYLIB_PRIVATE</strong> 및 <strong>MYLIB_PUBLIC</strong>을 정의하여 컴파일해야 한다.</li>
  <li>simple_example.cpp: <strong>MYLIB_PUBLIC</strong>을 정의하여 컴파일해야 하지만 MYLIB_PRIVATE는 정의하지 않는다.</li>
</ul>

<p>[ **target_compile_definitions(<target> <private or="" public=""> &lt;definition(s)&gt;)** ][ **target_compile_definitions** ]를 사용하여 **simple_lib**에 대한 정의를 설정한다.</private></target></p>

<h4 id="정답-1">정답</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.15...3.25)

project(MyExample01 LANGUAGES CXX)

# 헤더를 포함하는 라이브러리는 필수는 아니지만 유저들에게 좋다.
add_library(simple_lib simple_lib.cpp simple_lib.hpp)

# The above line *did not* set the includes - we need to We can also set ., and
# it should be expanded to the current source dir

# 위 라인은 includes를 설정하지 **않았다** - . 으로 설정할 수 있는데 현재 소스 디렉토리로 확장하는 게 좋다.
target_include_directories(simple_lib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}")

# 정의 추가
target_compile_definitions(simple_lib PUBLIC MYLIB_PUBLIC)
target_compile_definitions(simple_lib PRIVATE MYLIB_PRIVATE)

# C++ 특징 필요(여기서는 적어도 C++11 이상)
target_compile_features(simple_lib PUBLIC cxx_std_11)

# 이제 executable 추가
add_executable(simple_example simple_example.cpp)

# simple-lib에 가장 중요한 링크 추가
target_link_libraries(simple_example PUBLIC simple_lib)
</code></pre></div></div>

<h3 id="타겟에-설정할-수-있는-것">타겟에 설정할 수 있는 것</h3>

<ul>
  <li><strong>target_link_libraries</strong>: 기타 대상; 라이브러리 이름을 직접 전달할 수도 있다.</li>
  <li><strong>target_include_directories</strong>: 디렉터리 포함</li>
  <li><strong>target_compile_features</strong>: <strong>cxx_std_11</strong>과 같이 활성화해야 하는 컴파일러 기능</li>
  <li><strong>target_compile_definitions</strong>: 정의</li>
  <li><strong>target_compile_options</strong>: 보다 일반적인 컴파일 플래그</li>
  <li><strong>target_link_directories</strong>: 사용하지 말고 대신 전체 경로를 제공(CMake 3.13+)</li>
  <li><strong>target_link_options</strong>: 일반 링크 플래그(CMake 3.13+)</li>
  <li><strong>target_sources</strong>: 소스 파일 추가</li>
</ul>

<p><a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">여기에서 더 많은 명령</a>을 확인하자.</p>

<h2 id="타겟의-다른-형태">타겟의 다른 형태</h2>

<p>당신은 타겟에 대해 매우 흥미를 느끼고, 타겟 측면에서 프로그램을 설명할 수 있는 방법을 이미 계획하고 있을 것이다. 훌륭하다! 그러나 타겟 언어가 유용한 두 가지 상황에 빠르게 직면하겠지만, 우리가 다룬 내용에 대해 약간의 유연성이 필요하다.</p>

<p>첫째, 개념적으로는 타겟이어야 하지만 실제로는 빌드된 구성 요소가 없는 라이브러리, 즉 “헤더-전용” 라이브러리가 있을 수 있다. CMake에서는 이를 인터페이스(interface) 라이브러리라고 부르며 작성하게 된다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_library(some_header_only_lib INTERFACE)
</code></pre></div></div>

<p>소스 파일을 추가할 필요가 없다는 점에 유의하라. 이제 여기에만 <strong>INTERFACE</strong> 속성을 설정할 수 있다(빌드된 구성 요소가 없기 때문에).</p>

<p>두 번째 상황은 사용하려는 미리 빌드된 라이브러리가 있는 경우이다. CMake에서는 이를 가져온 라이브러리라고 하며 <strong>IMPORTED</strong> 키워드를 사용한다. 가져온 라이브러리는 <strong>INTERFACE</strong> 라이브러리일 수도 있으며, 다른 라이브러리와 동일한 구문(CMake 3.11부터 시작)을 사용하여 빌드하고 수정할 수 있으며 이름에 <strong>::</strong>를 사용할 수 있다(간단히 다른 라이브러리의 이름을 바꾸는 <strong>ALIAS</strong> 라이브러리도 <strong>::</strong>을 가질 수 있다). 대부분의 경우 다른 곳에서 라이브러리를 가져와서 직접 만들지는 않을 것이다.</p>

<h3 id="interface-imported">INTERFACE IMPORTED</h3>

<p><strong>가져온 인터페이스</strong>는 어떨까? 차이점은 두 가지로 요약된다:</p>
<ol>
  <li>IMPORTED 타겟은 내보낼 수 없다. 타겟을 저장하면, IMPORTED 타겟을 저장할 수 없다. 타겟을 다시 생성해야 한다 (또는 다시 찾아야 한다).</li>
  <li>IMPORTED 헤더 포함 디렉토리는 항상 SYSTEM으로 표시된다.</li>
</ol>

<p>따라서 IMPORTED 타겟은 패키지의 직접적인 부분이 아닌 것을 나타내야 한다.</p>

<h3 id="더-읽어보기">더 읽어보기</h3>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/chapters/basics.html">Modern CMake basics</a>을 기반으로 함</li>
  <li><a href="https://cmake.org/cmake/help/latest/index.html">CMake’s docs</a>도 읽어볼 것</li>
</ul>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>라이브러리 및 실행 파일은 타겟이다.</li>
  <li>타겟에는 유용한 속성이 많이 있다.</li>
  <li>타겟은 다른 타겟에 연결(링크)될 수 있다.</li>
  <li>링크 시 타겟의 어떤 부분이 상속되는지 제어할 수 있다.</li>
  <li>변수를 만드는 대신 INTERFACE 타겟을 만들 수 있다.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Working with Targets Overview 질문 타겟(target)은 어떻게 동작하는가? 목표 타겟(target) 설정 방법을 알아두자 linking 및 INTERFACE 속성 이해하자 INTERFACE 타겟(target) 만들기 타겟(Targets) 이제 CMake의 세 라인을 사용하여 단일 파일을 컴파일하는 방법을 알게 되었다. 하지만 종속성이 있는 파일이 두 개 이상 있으면 어떻게 될까? 프로젝트 구조에 대해 CMake에 알릴 수 있어야 하며 이는 프로젝트를 빌드하는 데 도움이 된다. 그러기 위해서는 target이 필요한다. 넌 이 타겟(target)은 이미 보았다: add_executable(myexample simple.cpp) 그러면 myexample 이름으로 “실행 가능한” 타겟이 만들어진다. 타겟 이름은 고유해야 한다(실제로 원하는 경우 실행 파일 이름을 타겟 이름이 아닌 다른 이름으로 설정할 수 있는 방법이 있다). 타겟은 다른 언어의 “객체(object)”와 매우 유사하며, 정보를 저장하고 있는 속성(멤버 변수)를 가지고 있다. 예를 들어 SOURCES 속성에는 simple.cpp가 있다. 또 다른 유형의 타겟 은 라이브러리(library)이다: add_library(mylibrary simplelib.cpp) 어떤 종류의 라이브러리를 만들고 싶은지 알고 있다면, 키워드 STATIC, SHARED 또는 MODULE을 추가할 수 있다. 기본값은 BUILD_SHARED_LIBS를 사용하여 사용자가 선택할 수 있는 일종의 “자동(auto)” 라이브러리이다. 빌드되지 않은 라이브러리도 만들 수 있다. 이에 대한 자세한 내용은 나중에 타겟으로 무엇을 할 수 있는지 살펴본다. 링킹(연길) 여러 타겟이 있으면 target_link_libraries 및 키워드를 사용하여 타겟 간의 관계를 설명할 수 있다. PUBLIC, PRIVATE, INTERFACE 중 하나이다. 라이브러리를 만들 때 이 키워드를 잊으면 안된다! CMake는 일반적으로 문제를 일으키는 이 타겟에 대해 이전 호환성 모드로 전환된다. 질문 my_lib.hpp 및 my_lib.cpp로 만든 my_lib 라이브러리가 있다. 컴파일하려면 최소한 C++14가 필요하다. 그런 다음 my_exe를 추가하고 my_lib가 필요한 경우 my_exe를 C++14 이상으로 컴파일해야 할까? 정답 이는 헤더에 따라 다르다. 헤더에 C++14가 포함된 경우, 이는 PUBLIC 요구 사항이다. 라이브러리와 사용자 모두에게 필요하다. 그러나 헤더가 모든 C++ 버전에서 유효하고 my_lib.cpp 내부 구현에만 C++14가 필요한 경우 이는 PRIVATE 요구 사항이다. 사용자는 강제로 C++14 모드로 들어갈 필요가 없다. 사용자에게 C++14가 필요하지만 라이브러리는 모든 C++ 버전으로 컴파일할 수 있다. 이는 INTERFACE 요구 사항이다. 그림 1: PUBLIC, PRIVATE 및 INTERFACE의 예. myprogram은 mylibrary를 통해 볼 수 있는 세 개의 라이브러리를 구축한다. Private 라이브러리는 영향을 미치지 않는다. 모든 타겟에는 값으로 채워질 수 있는 두 가지 속성 모음이 있다. “PRIVATE” 속성은 해당 대상을 빌드할 때 발생하는 작업을 제어하고, “INTERFACE” 속성은 이 타겟에 연결된 타겟에게 빌드 시 수행할 작업을 알려준다. PUBLIC 키워드는 두 속성 필드를 동시에 채운다. Example 1: 디렉토리 포함하기 target_include_directories(TargetA PRIVATE mydir)를 실행하면 TargetA의 INCLUDE_DIRECTORIES 속성에 mydir이 추가된다. 대신 INTERFACE 키워드를 사용하면 INTERFACE_INCLUDE_DIRECTORIES가 대신 추가되며 PUBLIC을 사용하는 경우 두 속성이 동시에 추가된다. Example 2: C++ standard C++ 표준 속성인 CXX_STANDARD가 있다. 이 속성을 설정할 수 있으며 CMake의 많은 속성과 마찬가지로 설정된 경우 CMAKE_CXX_STANDARD 변수에서 기본값을 가져오지만 INTERFACE 버전이 없다. 타겟을 통해 CXX_STANDARD를 강제할 수 없다. C++11 인터페이스 타겟과 C++14 인터페이스 타겟이 있고 둘 다에 연결되어 있다면 어떻게 해야할까? 그런데 이를 처리하는 방법이 있다. 타겟을 컴파일하는 데 필요한 최소 컴파일 기능을 지정할 수 있다. cxx_std_11 및 유사한 메타 기능은 이에 적합하다. CXX_STANDARD가 설정되지 않는 한 타겟은 최소한 지정된 최고 레벨로 컴파일됩니다(그리고 CXX_STANDARD를 너무 낮게 설정하면 이는 훌륭하고 명확한 오류이다). target_compile_features는 예제 1의 디렉터리와 마찬가지로 COMPILE_FEATURES 및 INTERFACE_COMPILE_FEATURES를 채울 수 있다. 시도해보기 이 저장소를 가져와 예제로 이동해보라. 올바르게 빌드되는 CMakeList를 작성해 보자. git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git cd hsf-training-cmake-webpage/code/01-simple 여기에 있는 파일은 다음과 같다. simple_lib.cpp: MYLIB_PRIVATE 및 MYLIB_PUBLIC을 정의하여 컴파일해야 한다. simple_example.cpp: MYLIB_PUBLIC을 정의하여 컴파일해야 하지만 MYLIB_PRIVATE는 정의하지 않는다. [ **target_compile_definitions( &lt;definition(s)&gt;)** ][ **target_compile_definitions** ]를 사용하여 **simple_lib**에 대한 정의를 설정한다. 정답 cmake_minimum_required(VERSION 3.15...3.25) project(MyExample01 LANGUAGES CXX) # 헤더를 포함하는 라이브러리는 필수는 아니지만 유저들에게 좋다. add_library(simple_lib simple_lib.cpp simple_lib.hpp) # The above line *did not* set the includes - we need to We can also set ., and # it should be expanded to the current source dir # 위 라인은 includes를 설정하지 **않았다** - . 으로 설정할 수 있는데 현재 소스 디렉토리로 확장하는 게 좋다. target_include_directories(simple_lib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}") # 정의 추가 target_compile_definitions(simple_lib PUBLIC MYLIB_PUBLIC) target_compile_definitions(simple_lib PRIVATE MYLIB_PRIVATE) # C++ 특징 필요(여기서는 적어도 C++11 이상) target_compile_features(simple_lib PUBLIC cxx_std_11) # 이제 executable 추가 add_executable(simple_example simple_example.cpp) # simple-lib에 가장 중요한 링크 추가 target_link_libraries(simple_example PUBLIC simple_lib) 타겟에 설정할 수 있는 것 target_link_libraries: 기타 대상; 라이브러리 이름을 직접 전달할 수도 있다. target_include_directories: 디렉터리 포함 target_compile_features: cxx_std_11과 같이 활성화해야 하는 컴파일러 기능 target_compile_definitions: 정의 target_compile_options: 보다 일반적인 컴파일 플래그 target_link_directories: 사용하지 말고 대신 전체 경로를 제공(CMake 3.13+) target_link_options: 일반 링크 플래그(CMake 3.13+) target_sources: 소스 파일 추가 여기에서 더 많은 명령을 확인하자. 타겟의 다른 형태 당신은 타겟에 대해 매우 흥미를 느끼고, 타겟 측면에서 프로그램을 설명할 수 있는 방법을 이미 계획하고 있을 것이다. 훌륭하다! 그러나 타겟 언어가 유용한 두 가지 상황에 빠르게 직면하겠지만, 우리가 다룬 내용에 대해 약간의 유연성이 필요하다. 첫째, 개념적으로는 타겟이어야 하지만 실제로는 빌드된 구성 요소가 없는 라이브러리, 즉 “헤더-전용” 라이브러리가 있을 수 있다. CMake에서는 이를 인터페이스(interface) 라이브러리라고 부르며 작성하게 된다: add_library(some_header_only_lib INTERFACE) 소스 파일을 추가할 필요가 없다는 점에 유의하라. 이제 여기에만 INTERFACE 속성을 설정할 수 있다(빌드된 구성 요소가 없기 때문에). 두 번째 상황은 사용하려는 미리 빌드된 라이브러리가 있는 경우이다. CMake에서는 이를 가져온 라이브러리라고 하며 IMPORTED 키워드를 사용한다. 가져온 라이브러리는 INTERFACE 라이브러리일 수도 있으며, 다른 라이브러리와 동일한 구문(CMake 3.11부터 시작)을 사용하여 빌드하고 수정할 수 있으며 이름에 ::를 사용할 수 있다(간단히 다른 라이브러리의 이름을 바꾸는 ALIAS 라이브러리도 ::을 가질 수 있다). 대부분의 경우 다른 곳에서 라이브러리를 가져와서 직접 만들지는 않을 것이다. INTERFACE IMPORTED 가져온 인터페이스는 어떨까? 차이점은 두 가지로 요약된다: IMPORTED 타겟은 내보낼 수 없다. 타겟을 저장하면, IMPORTED 타겟을 저장할 수 없다. 타겟을 다시 생성해야 한다 (또는 다시 찾아야 한다). IMPORTED 헤더 포함 디렉토리는 항상 SYSTEM으로 표시된다. 따라서 IMPORTED 타겟은 패키지의 직접적인 부분이 아닌 것을 나타내야 한다. 더 읽어보기 Modern CMake basics을 기반으로 함 CMake’s docs도 읽어볼 것 핵심사항 라이브러리 및 실행 파일은 타겟이다. 타겟에는 유용한 속성이 많이 있다. 타겟은 다른 타겟에 연결(링크)될 수 있다. 링크 시 타겟의 어떤 부분이 상속되는지 제어할 수 있다. 변수를 만드는 대신 INTERFACE 타겟을 만들 수 있다.]]></summary></entry><entry><title type="html">More Modern CMake - Your first CMakeLists.txt file</title><link href="http://localhost:4000/more-modern-cmake-your-first-file" rel="alternate" type="text/html" title="More Modern CMake - Your first CMakeLists.txt file" /><published>2024-01-20T00:00:00+09:00</published><updated>2024-01-20T00:00:00+09:00</updated><id>http://localhost:4000/00-more-modern-cmake-your-first-file</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-your-first-file"><![CDATA[<h1 id="your-first-cmakeliststxt-file">Your first CMakeLists.txt file</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>내 CMakeLists에서 얼마나 최소화할 수 있는가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li><strong>cmake_minimum_version</strong>의 깊은 의미를 이해하자.</li>
      <li>project 설정 방법을 알아두자.</li>
      <li>적어도 하나의 타겟을 만드는 방법을 알아두자.</li>
    </ul>
  </li>
</ul>

<h2 id="cmakelists-파일-작성">CMakeLists 파일 작성</h2>

<p>다음 파일은 그 다음 예에 적합하다 :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* simple.c or simple.cpp */
#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}
</code></pre></div></div>

<h3 id="시작하기">시작하기</h3>

<p>이것은 가장 간단한 <strong>CMakeLists.txt</strong> 이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.15)

project(MyProject)

add_executable(myexample simple.cpp)
</code></pre></div></div>

<p>세 줄을 살펴보자 :</p>

<ol>
  <li>cmake_minimum_required 명령어는 빌드가 CMake의 나열된 버전에 있는 것과 정확히 똑같은 정책을 설정한다. 즉, CMake는 다른 빌드으로 생성할 수 있는 모든 기능에 대해 사용자가 요청한 버전으로 “자체적으로 낮춘다”. 이로 인해 CMake는 거의 완벽하게 이전 버전과 호환된다.</li>
  <li>프로젝트를 진행 중이어야 하며 최소한 이름이 필요하다. CMake는 LANGUAGE를 제공하지 않으면 CXX(C++) 및 C 혼합 프로젝트를 가정한다.</li>
  <li>흥미로운 작업을 수행하려면 최소한 하나의 라이브러리나 실행 파일이 필요하다. 여기서 만드는 “무엇”을 “타겟(target)”이라고 하며, 실행 파일/라이브러리는 기본적으로 이름이 동일하고 프로젝트에서 고유해야 한다. 프로그램에는 add_executable을 사용하고, 라이브러리에서는 add_library를 사용한다.</li>
</ol>

<p>이러한 명령에 제공할 수 있는 몇 가지 추가 인수가 있다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.15...3.25)

project(MyProject
  VERSION
    1.0
  DESCRIPTION
    "Very nice project"
  LANGUAGES
    CXX
)

add_executable(myexample simple.cpp)
</code></pre></div></div>

<ol>
  <li>버전 범위를 지정할 수 있다 - 이렇게 하면 정책이 해당 범위에서 지원되는 가장 높은 값으로 설정된다. 일반적으로, 여기에서 테스트해 본 가장 높은 버전을 설정해라.</li>
  <li>프로젝트에는 버전, 설명 및 언어를 가질 수 있다.</li>
  <li>공백은 중요하지 않다. 명확하고 예쁘거나 <a href="https://cmake-format.readthedocs.io/en/latest/">cmake-format</a>을 사용하라.</li>
</ol>

<h3 id="시도해보기">시도해보기</h3>

<p>위와 유사한 CMakeLists.txt를 사용하여 예제 코드를 빌드하고 실행해본다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git
cd hsf-training-cmake-webpage/code/00-intro
</code></pre></div></div>

<h4 id="정답">정답</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 이것은 모든 CMakeLists에 필요합니다. 적절한 최소 버전과 범위를 선택하자.
cmake_minimum_required(VERSION 3.15...3.25)

# 우리는 우리가 원하는 것으로 프로젝트를 지정할 수 있고 
# 언어(들)을 적으면 기본 C + CXX 을 피할 수 있다.
project(MyExample00 LANGUAGES C)

# 실행가능한 타겟이 필요하다.
add_executable(simple_example simple.c)
</code></pre></div></div>

<h3 id="더-읽어보기">더 읽어보기</h3>

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/basics.html">Modern CMake basics</a>을 기반으로 함.</p>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>cmake_minimum_version 설정은 깊은 의미를 갖는다.</li>
  <li>project 설정 라인이 필요하다.</li>
  <li>흥미로운 일을 하려면 하나 이상의 타겟(target)를 준비해야 한다.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Your first CMakeLists.txt file Overview 질문 내 CMakeLists에서 얼마나 최소화할 수 있는가? 목표 cmake_minimum_version의 깊은 의미를 이해하자. project 설정 방법을 알아두자. 적어도 하나의 타겟을 만드는 방법을 알아두자. CMakeLists 파일 작성 다음 파일은 그 다음 예에 적합하다 : /* simple.c or simple.cpp */ #include &lt;stdio.h&gt; int main() { printf("Hello, World!\n"); return 0; } 시작하기 이것은 가장 간단한 CMakeLists.txt 이다. cmake_minimum_required(VERSION 3.15) project(MyProject) add_executable(myexample simple.cpp) 세 줄을 살펴보자 : cmake_minimum_required 명령어는 빌드가 CMake의 나열된 버전에 있는 것과 정확히 똑같은 정책을 설정한다. 즉, CMake는 다른 빌드으로 생성할 수 있는 모든 기능에 대해 사용자가 요청한 버전으로 “자체적으로 낮춘다”. 이로 인해 CMake는 거의 완벽하게 이전 버전과 호환된다. 프로젝트를 진행 중이어야 하며 최소한 이름이 필요하다. CMake는 LANGUAGE를 제공하지 않으면 CXX(C++) 및 C 혼합 프로젝트를 가정한다. 흥미로운 작업을 수행하려면 최소한 하나의 라이브러리나 실행 파일이 필요하다. 여기서 만드는 “무엇”을 “타겟(target)”이라고 하며, 실행 파일/라이브러리는 기본적으로 이름이 동일하고 프로젝트에서 고유해야 한다. 프로그램에는 add_executable을 사용하고, 라이브러리에서는 add_library를 사용한다. 이러한 명령에 제공할 수 있는 몇 가지 추가 인수가 있다: cmake_minimum_required(VERSION 3.15...3.25) project(MyProject VERSION 1.0 DESCRIPTION "Very nice project" LANGUAGES CXX ) add_executable(myexample simple.cpp) 버전 범위를 지정할 수 있다 - 이렇게 하면 정책이 해당 범위에서 지원되는 가장 높은 값으로 설정된다. 일반적으로, 여기에서 테스트해 본 가장 높은 버전을 설정해라. 프로젝트에는 버전, 설명 및 언어를 가질 수 있다. 공백은 중요하지 않다. 명확하고 예쁘거나 cmake-format을 사용하라. 시도해보기 위와 유사한 CMakeLists.txt를 사용하여 예제 코드를 빌드하고 실행해본다. git clone https://github.com/hsf-training/hsf-training-cmake-webpage.git cd hsf-training-cmake-webpage/code/00-intro 정답 # 이것은 모든 CMakeLists에 필요합니다. 적절한 최소 버전과 범위를 선택하자. cmake_minimum_required(VERSION 3.15...3.25) # 우리는 우리가 원하는 것으로 프로젝트를 지정할 수 있고 # 언어(들)을 적으면 기본 C + CXX 을 피할 수 있다. project(MyExample00 LANGUAGES C) # 실행가능한 타겟이 필요하다. add_executable(simple_example simple.c) 더 읽어보기 Modern CMake basics을 기반으로 함. 핵심사항 cmake_minimum_version 설정은 깊은 의미를 갖는다. project 설정 라인이 필요하다. 흥미로운 일을 하려면 하나 이상의 타겟(target)를 준비해야 한다.]]></summary></entry><entry><title type="html">More Modern CMake - Building with CMake</title><link href="http://localhost:4000/more-modern-cmake-build-with-cmake" rel="alternate" type="text/html" title="More Modern CMake - Building with CMake" /><published>2024-01-18T00:00:00+09:00</published><updated>2024-01-18T00:00:00+09:00</updated><id>http://localhost:4000/18-more-modern-cmake-building-with-cmake</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-build-with-cmake"><![CDATA[<h1 id="building-with-cmake">Building With CMake</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>프로젝트를 어떻게 빌드하는가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>CMake 설치에 대한 참고.</li>
      <li>기존 프로젝트를 빌드하는 방법을 알아보자.</li>
      <li>빌드를 사용자 정의한다.</li>
      <li>몇 가지 기본적인 디버깅을 수행하는 방법을 알아보자.</li>
    </ul>
  </li>
</ul>

<h2 id="cmake-설치">CMake 설치</h2>

<p>거의 모든 곳에 최신 버전의 CMake를 설치하는 데 일반적으로 한 줄 또는 두 줄에 불과하다. <a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">CMake 설명</a>을 참조.</p>

<h2 id="cmake-로-빌드하기">CMake 로 빌드하기</h2>

<p>CMake를 작성하기 전에 CMake를 실행하여 만드는 방법을 알고 있는지 확인하겠다. 이는 거의 모든 CMake 프로젝트에 해당된다.</p>

<h3 id="try-it-out">Try it out</h3>

<p>프로젝트를 하나 가져와서 빌드해 보자. 재미삼아 CLI11을 빌드해본다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/CLIUtils/CLI11.git
cd CLI11
</code></pre></div></div>

<p>이제 새로 다운로드된 디렉토리에서 모던 CMake(3.14) 빌드 절차를 시도해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake -S . -B build
cmake --build build
cmake --build build -t test
</code></pre></div></div>

<p>빌드 디렉터리(<strong>-B</strong>)가 존재하지 않을 경우 빌드 디렉터리를 만들고, 소스 디렉터리는 <strong>-S</strong>로 정의한다. CMake는 기본적으로 makefile을 구성하고 생성할 뿐만 아니라 모든 옵션을 기본 설정으로 설정하고 이를 빌드 디렉터리에 있는 <strong>CMakeCache.txt</strong>라는 파일에 캐시한다. 관례적으로 대부분의 패키지의 <strong>.gitignore</strong> 파일에서 무시하려면 <strong>build</strong>라는 단어가 있어야 한다.</p>

<p>그런 다음 빌드 시스템을 호출할 수 있다(2번째 줄). <strong>make</strong>(기본값), <strong>ninja</strong> 또는 IDE 기반 시스템을 사용했는지 여부에 관계없이 동일한 명령을 사용하여 빌드할 수 있다. <strong>-j 2</strong>를 추가하여 두 개의 코어에 빌드하거나 <strong>-v</strong>를 추가하여 빌드에 사용된 명령을 자세히 표시할 수 있다.</p>

<p>마지막으로 “test” 대상을 기본 빌드 시스템에 전달하여 여기에서 테스트를 실행할 수도 있다. <strong>-t</strong>(CMake 3.15 이전에는 <strong>–target</strong>)를 사용하면 대상을 선택할 수 있다. CMake 3.15+에는 기본 빌드 시스템을 호출하지 않고 설치를 수행하는 <strong>cmake &lt;dir&gt; –install</strong> 명령도 있다!</p>

<h3 id="소스-안에서-빌드하는-것의-경고">소스 안에서 빌드하는 것의 경고</h3>

<p>소스 디렉토리에서 절대로 “소스 내” 빌드 - 즉, <strong>cmake .</strong> 를 실행하면 안된다. 소스 디렉토리를 빌드 결과물, CMake 구성 파일로 오염시키고 소스 외부 빌드를 비활성화한다. 몇 개의 패키지는 소스 디렉토리가 빌드 디렉토리 내부에 위치하는 것조차 허용하지 않는다. 그런 경우 상대 경로(<strong>..</strong>)를 적절히 변경해야 한다.</p>

<p>간단히 설명하자면, CMake는 빌드 디렉토리의 소스 디렉토리 또는 어디에서나 기존 빌드 디렉토리를 가리킬 수 있다.</p>

<h3 id="다른-구문-선택">다른 구문 선택</h3>

<p>완전성을 위해 고전적인 방법이 보여주는 것이 좋겠다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir build
cd build
cmake ..
make
make test
</code></pre></div></div>

<p>여기에는 몇 가지 단점이 있다. 디렉터리가 이미 존재하는 경우 <strong>-p</strong>를 추가해야 하지만 Windows에서는 작동하지 않는다. 당신은 그 디렉토리 안에 있기 때문에 빌드 디렉토리 사이를 쉽게 변경할 수 없다. 라인이 더 많아지고, 빌드 디렉터리로 변경하는 것을 잊어버린 경우 <strong>cmake ..</strong> 대신 <strong>cmake .</strong> 를 사용한다. 그럴 경우 소스 디렉토리를 오염시킬 수 있다.</p>

<h2 id="컴파일러-선택하기">컴파일러 선택하기</h2>

<p>컴파일러 선택은 빈 디렉터리에서 처음 실행할 때 수행되어야 한다. CMake 구문 자체는 아니지만 익숙하지 않을 수도 있다. Clang을 선택하려면:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC=clang CXX=clang++ cmake -S . -B build
</code></pre></div></div>

<p>그러면 <strong>CC</strong> 및 <strong>CXX</strong>에 대해 bash에서 환경 변수로 설정되고 CMake는 해당 변수를 고려할 것이다. 이렇게 하면 해당 한 라인에 대해서만 설정되지만, 필요한 경우는 딱 저 시간 뿐이다. 이후 CMake는 해당 값에서 추론한 경로를 계속 사용한다.</p>

<h2 id="생성기-선택하기">생성기 선택하기</h2>

<p>다양한 툴을 사용하여 빌드할 수 있다. <strong>make</strong>는 일반적으로 기본값이다. CMake가 시스템에서 알고 있는 모든 툴을 보려면 다음을 실행하자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake --help
</code></pre></div></div>

<p>그리고 <strong>-G”My Tool”</strong>을 사용하여 툴을 선택할 수 있다(툴 이름에 공백이 있는 경우에만 큰따옴표가 필요). 컴파일러와 마찬가지로 디렉터리에서 처음 CMake 호출 시 툴을 선택해야 한다. <strong>build</strong> 및 <strong>build-xcode</strong>와 같이 여러 빌드 디렉터리를 자유롭게 사용할 수 있다. 환경 변수 <strong>CMAKE_GENERATOR</strong>를 설정하여 기본 생성기(CMake 3.15+)를 조작할 수 있다. makefile은 <strong>make -j2</strong>와 같이 명시적으로 여러 스레드를 전달하는 경우에만 병렬로 실행되는 반면, Ninja는 자동으로 병렬로 실행된다. 최근 버전의 CMake에서도 <strong>-j 2</strong>와 같은 병렬화 옵션을 <strong>cmake –build .</strong> 명령에 직접 전달할 수 있다.</p>

<h2 id="옵션-설정하기">옵션 설정하기</h2>

<p><strong>-D</strong>를 사용하여 CMake에서 옵션을 설정한다. <strong>-L</strong>을 사용하면 옵션 목록을 볼 수 있고, <strong>-LH</strong>를 사용하면 사람이 읽을 수 있는 도움말 목록을 볼 수 있다.</p>

<h2 id="상세-및-부분-빌드">상세 및 부분 빌드</h2>

<p>다시 말하지만, CMake는 아니지만 <strong>make</strong>와 같은 커맨드 라인 빌드 툴을 사용하는 경우, 자세한 빌드를 얻을 수 있다:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake --build build -v
</code></pre></div></div>
<p>make를 직접 사용하는 경우, <strong>VERBOSE=1 make</strong> 또는 <strong>make VERBOSE=1</strong>이라고 쓸 수 있으며, 비록 명령 뒤에 변수를 쓰는 것은 <strong>make</strong>의 기능이고 일반적인 커맨드 라인 방식이 아니지만, make 역시 올바른 작업을 수행할 것이다.</p>

<p>CMake에서 정의한 라이브러리 또는 실행 파일의 이름과 같은 대상을 지정하여 빌드의 일부만 빌드할 수도 있으며 make는 해당 대상만 빌드한다. 이것이 <strong>–target</strong>(CMake 3.15+에서는 <strong>-t</strong>) 옵션이다.</p>

<h2 id="옵션들">옵션들</h2>

<p>CMake는 캐시된 옵션을 지원한다. CMake의 변수는 “캐시됨”으로 표시될 수 있는데, 이 의미는 변수가 발견되면 캐시(빌드 디렉터리에 있는 <strong>CMakeCache.txt</strong>라는 파일)에 기록된다는 의미이다. <strong>-D</strong>를 사용하여 커맨드라인에서 캐시된 옵션 값을 미리 설정(또는 변경)할 수 있다. CMake가 캐시된 변수를 찾을 때는 기존 값을 사용하고 덮어쓰지 않는다.</p>

<h3 id="표준-옵션들">표준 옵션들</h3>

<p>이는 대부분의 패키지에 대한 일반적인 CMake 옵션들이다:</p>
<ul>
  <li><strong>CMAKE_BUILD_TYPE</strong>: <strong>Release</strong>, <strong>RelWithDebInfo</strong>, <strong>Debug</strong> 등에서 선택</li>
  <li><strong>CMAKE_INSTALL_PREFIX</strong>: 설치할 위치. UNIX의 시스템 설치는 종종 <strong>/usr/local</strong>(기본값)이고, 사용자 디렉터리는 대개 <strong>~/.local</strong>이거나 폴더를 선택할 수 있다.</li>
  <li><strong>BUILD_SHARED_LIBS</strong>: <strong>ON</strong> 또는 <strong>OFF</strong>로 설정하여 공유 라이브러리의 기본값을 제어할 수 있다. (단, 작성자는 기본값을 사용하는 대신 명시적으로 둘 중 하나를 선택할 수 있다)</li>
  <li><strong>BUILD_TESTING</strong>: 이는 테스트를 활성화하기 위한 일반적인 이름이다. 다만 때때로 적절한 이유로 인해 모든 패키지에서 이를 사용하는 것은 아니다.</li>
</ul>

<h3 id="시도해보기">시도해보기</h3>

<p>복제한 CLI11 저장소에서:</p>

<ul>
  <li>어떤 옵션을 사용할 수 있는지 확인</li>
  <li>값을 변경한다; <strong>CMAKE_CXX_STANDARD</strong>를 14로 설정하거나 테스트를 끌 수도 있다.</li>
  <li><strong>CMAKE_INSTALL_PREFIX=install</strong>로 구성한 다음 해당 로컬 디렉터리에 설치한다. 거기에서 보여지는 지 확인하라!</li>
</ul>

<h2 id="cmake-파일들-디버깅">CMake 파일들 디버깅</h2>

<p>이미 빌드에 대한 자세한 출력을 언급했지만 자세한 CMake 구성 출력도 볼 수 있다. <strong>–trace</strong> 옵션은 실행되는 CMake의 모든 라인을 인쇄한다. 이것은 매우 장황하기 때문에, CMake 3.7에는 <strong>–trace-source=”filename”</strong>을 추가하여 실행 시 관심있는 파일의 모든 실행 라인을 출력한다. 디버깅에 관심이 있는 파일 이름을 선택하면(CMakeLists.txt를 디버깅하는 경우 모든 이름이 동일하므로 일반적으로 상위 디렉터리 사용) 해당 파일에서 실행되는 라인만 볼 수 있다. 굉장히 유용하다!</p>

<h3 id="시도해보기-1">시도해보기</h3>

<p>소스 디렉터리에서 다음을 실행한다:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake build --trace-source="CMakeLists.txt"
</code></pre></div></div>

<h3 id="답해보자">답해보자.</h3>

<p>질문: <strong>cmake build</strong>는 무엇이든 빌드하는가?
답 : 아니, 여기서 “빌드”는 디렉터리이다. 이것은 (빌드 시스템 파일을) 구성한다. 빌드하려면 디렉터리 앞에 <strong>–build</strong>를 추가하거나 <strong>make</strong>와 같은 빌드 툴을 사용한다.</p>

<h3 id="더-읽어보기">더 읽어보기</h3>

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/running.html">Modern CMake intro/running</a>을 기반으로 함.</p>

<h2 id="핵심사항">핵심사항</h2>

<ul>
  <li>프로젝트를 빌드.</li>
  <li>소스 외부 빌드를 사용하자.</li>
  <li>빌드 옵션 및 사용자 정의.</li>
  <li>CMakeList를 쉽게 디버그.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Building With CMake Overview 질문 프로젝트를 어떻게 빌드하는가? 목표 CMake 설치에 대한 참고. 기존 프로젝트를 빌드하는 방법을 알아보자. 빌드를 사용자 정의한다. 몇 가지 기본적인 디버깅을 수행하는 방법을 알아보자. CMake 설치 거의 모든 곳에 최신 버전의 CMake를 설치하는 데 일반적으로 한 줄 또는 두 줄에 불과하다. CMake 설명을 참조. CMake 로 빌드하기 CMake를 작성하기 전에 CMake를 실행하여 만드는 방법을 알고 있는지 확인하겠다. 이는 거의 모든 CMake 프로젝트에 해당된다. Try it out 프로젝트를 하나 가져와서 빌드해 보자. 재미삼아 CLI11을 빌드해본다. git clone https://github.com/CLIUtils/CLI11.git cd CLI11 이제 새로 다운로드된 디렉토리에서 모던 CMake(3.14) 빌드 절차를 시도해보자. cmake -S . -B build cmake --build build cmake --build build -t test 빌드 디렉터리(-B)가 존재하지 않을 경우 빌드 디렉터리를 만들고, 소스 디렉터리는 -S로 정의한다. CMake는 기본적으로 makefile을 구성하고 생성할 뿐만 아니라 모든 옵션을 기본 설정으로 설정하고 이를 빌드 디렉터리에 있는 CMakeCache.txt라는 파일에 캐시한다. 관례적으로 대부분의 패키지의 .gitignore 파일에서 무시하려면 build라는 단어가 있어야 한다. 그런 다음 빌드 시스템을 호출할 수 있다(2번째 줄). make(기본값), ninja 또는 IDE 기반 시스템을 사용했는지 여부에 관계없이 동일한 명령을 사용하여 빌드할 수 있다. -j 2를 추가하여 두 개의 코어에 빌드하거나 -v를 추가하여 빌드에 사용된 명령을 자세히 표시할 수 있다. 마지막으로 “test” 대상을 기본 빌드 시스템에 전달하여 여기에서 테스트를 실행할 수도 있다. -t(CMake 3.15 이전에는 –target)를 사용하면 대상을 선택할 수 있다. CMake 3.15+에는 기본 빌드 시스템을 호출하지 않고 설치를 수행하는 cmake &lt;dir&gt; –install 명령도 있다! 소스 안에서 빌드하는 것의 경고 소스 디렉토리에서 절대로 “소스 내” 빌드 - 즉, cmake . 를 실행하면 안된다. 소스 디렉토리를 빌드 결과물, CMake 구성 파일로 오염시키고 소스 외부 빌드를 비활성화한다. 몇 개의 패키지는 소스 디렉토리가 빌드 디렉토리 내부에 위치하는 것조차 허용하지 않는다. 그런 경우 상대 경로(..)를 적절히 변경해야 한다. 간단히 설명하자면, CMake는 빌드 디렉토리의 소스 디렉토리 또는 어디에서나 기존 빌드 디렉토리를 가리킬 수 있다. 다른 구문 선택 완전성을 위해 고전적인 방법이 보여주는 것이 좋겠다. mkdir build cd build cmake .. make make test 여기에는 몇 가지 단점이 있다. 디렉터리가 이미 존재하는 경우 -p를 추가해야 하지만 Windows에서는 작동하지 않는다. 당신은 그 디렉토리 안에 있기 때문에 빌드 디렉토리 사이를 쉽게 변경할 수 없다. 라인이 더 많아지고, 빌드 디렉터리로 변경하는 것을 잊어버린 경우 cmake .. 대신 cmake . 를 사용한다. 그럴 경우 소스 디렉토리를 오염시킬 수 있다. 컴파일러 선택하기 컴파일러 선택은 빈 디렉터리에서 처음 실행할 때 수행되어야 한다. CMake 구문 자체는 아니지만 익숙하지 않을 수도 있다. Clang을 선택하려면: CC=clang CXX=clang++ cmake -S . -B build 그러면 CC 및 CXX에 대해 bash에서 환경 변수로 설정되고 CMake는 해당 변수를 고려할 것이다. 이렇게 하면 해당 한 라인에 대해서만 설정되지만, 필요한 경우는 딱 저 시간 뿐이다. 이후 CMake는 해당 값에서 추론한 경로를 계속 사용한다. 생성기 선택하기 다양한 툴을 사용하여 빌드할 수 있다. make는 일반적으로 기본값이다. CMake가 시스템에서 알고 있는 모든 툴을 보려면 다음을 실행하자. cmake --help 그리고 -G”My Tool”을 사용하여 툴을 선택할 수 있다(툴 이름에 공백이 있는 경우에만 큰따옴표가 필요). 컴파일러와 마찬가지로 디렉터리에서 처음 CMake 호출 시 툴을 선택해야 한다. build 및 build-xcode와 같이 여러 빌드 디렉터리를 자유롭게 사용할 수 있다. 환경 변수 CMAKE_GENERATOR를 설정하여 기본 생성기(CMake 3.15+)를 조작할 수 있다. makefile은 make -j2와 같이 명시적으로 여러 스레드를 전달하는 경우에만 병렬로 실행되는 반면, Ninja는 자동으로 병렬로 실행된다. 최근 버전의 CMake에서도 -j 2와 같은 병렬화 옵션을 cmake –build . 명령에 직접 전달할 수 있다. 옵션 설정하기 -D를 사용하여 CMake에서 옵션을 설정한다. -L을 사용하면 옵션 목록을 볼 수 있고, -LH를 사용하면 사람이 읽을 수 있는 도움말 목록을 볼 수 있다. 상세 및 부분 빌드 다시 말하지만, CMake는 아니지만 make와 같은 커맨드 라인 빌드 툴을 사용하는 경우, 자세한 빌드를 얻을 수 있다: cmake --build build -v make를 직접 사용하는 경우, VERBOSE=1 make 또는 make VERBOSE=1이라고 쓸 수 있으며, 비록 명령 뒤에 변수를 쓰는 것은 make의 기능이고 일반적인 커맨드 라인 방식이 아니지만, make 역시 올바른 작업을 수행할 것이다. CMake에서 정의한 라이브러리 또는 실행 파일의 이름과 같은 대상을 지정하여 빌드의 일부만 빌드할 수도 있으며 make는 해당 대상만 빌드한다. 이것이 –target(CMake 3.15+에서는 -t) 옵션이다. 옵션들 CMake는 캐시된 옵션을 지원한다. CMake의 변수는 “캐시됨”으로 표시될 수 있는데, 이 의미는 변수가 발견되면 캐시(빌드 디렉터리에 있는 CMakeCache.txt라는 파일)에 기록된다는 의미이다. -D를 사용하여 커맨드라인에서 캐시된 옵션 값을 미리 설정(또는 변경)할 수 있다. CMake가 캐시된 변수를 찾을 때는 기존 값을 사용하고 덮어쓰지 않는다. 표준 옵션들 이는 대부분의 패키지에 대한 일반적인 CMake 옵션들이다: CMAKE_BUILD_TYPE: Release, RelWithDebInfo, Debug 등에서 선택 CMAKE_INSTALL_PREFIX: 설치할 위치. UNIX의 시스템 설치는 종종 /usr/local(기본값)이고, 사용자 디렉터리는 대개 ~/.local이거나 폴더를 선택할 수 있다. BUILD_SHARED_LIBS: ON 또는 OFF로 설정하여 공유 라이브러리의 기본값을 제어할 수 있다. (단, 작성자는 기본값을 사용하는 대신 명시적으로 둘 중 하나를 선택할 수 있다) BUILD_TESTING: 이는 테스트를 활성화하기 위한 일반적인 이름이다. 다만 때때로 적절한 이유로 인해 모든 패키지에서 이를 사용하는 것은 아니다. 시도해보기 복제한 CLI11 저장소에서: 어떤 옵션을 사용할 수 있는지 확인 값을 변경한다; CMAKE_CXX_STANDARD를 14로 설정하거나 테스트를 끌 수도 있다. CMAKE_INSTALL_PREFIX=install로 구성한 다음 해당 로컬 디렉터리에 설치한다. 거기에서 보여지는 지 확인하라! CMake 파일들 디버깅 이미 빌드에 대한 자세한 출력을 언급했지만 자세한 CMake 구성 출력도 볼 수 있다. –trace 옵션은 실행되는 CMake의 모든 라인을 인쇄한다. 이것은 매우 장황하기 때문에, CMake 3.7에는 –trace-source=”filename”을 추가하여 실행 시 관심있는 파일의 모든 실행 라인을 출력한다. 디버깅에 관심이 있는 파일 이름을 선택하면(CMakeLists.txt를 디버깅하는 경우 모든 이름이 동일하므로 일반적으로 상위 디렉터리 사용) 해당 파일에서 실행되는 라인만 볼 수 있다. 굉장히 유용하다! 시도해보기 소스 디렉터리에서 다음을 실행한다: cmake build --trace-source="CMakeLists.txt" 답해보자. 질문: cmake build는 무엇이든 빌드하는가? 답 : 아니, 여기서 “빌드”는 디렉터리이다. 이것은 (빌드 시스템 파일을) 구성한다. 빌드하려면 디렉터리 앞에 –build를 추가하거나 make와 같은 빌드 툴을 사용한다. 더 읽어보기 Modern CMake intro/running을 기반으로 함. 핵심사항 프로젝트를 빌드. 소스 외부 빌드를 사용하자. 빌드 옵션 및 사용자 정의. CMakeList를 쉽게 디버그.]]></summary></entry><entry><title type="html">More Modern CMake - Introduction</title><link href="http://localhost:4000/more-modern-cmake-introduction" rel="alternate" type="text/html" title="More Modern CMake - Introduction" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/00-more-modern-cmake-introduction</id><content type="html" xml:base="http://localhost:4000/more-modern-cmake-introduction"><![CDATA[<h1 id="introduction">Introduction</h1>

<h2 id="overview">Overview</h2>

<ul>
  <li>질문
    <ul>
      <li>빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가?</li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다</li>
      <li>CMake가 사용되는 이유를 이해한다.</li>
      <li>최신 CMake가 더 좋다.</li>
    </ul>
  </li>
</ul>

<p>코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다.</p>

<p>그래서 사람들은 <strong>빌드 시스템</strong>을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다.</p>

<p>그러나 이는 다음과 같다.</p>
<ul>
  <li>대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다.</li>
  <li>플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다.</li>
  <li>종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다.</li>
  <li>확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다.</li>
</ul>

<p>빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다.</p>

<p>CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다.</p>

<p>요약하면 다음과 같은 경우 CMake를 사용해야 한다.</p>
<ul>
  <li>하드 코딩 경로를 피하고 싶은 경우</li>
  <li>두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우</li>
  <li>CI(지속적 통합)를 사용하고 싶은 경우</li>
  <li>다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음)</li>
  <li>여러 컴파일러를 지원하고 싶은 경우</li>
  <li>IDE를 사용하고 싶지만 항상 그렇지는 않을 경우</li>
  <li>플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우</li>
  <li>라이브러리를 이용하고 싶은 경우</li>
  <li>Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우</li>
  <li>디버거를 사용하려는 경우</li>
</ul>

<h1 id="more-modern-cmake">(More) Modern CMake</h1>

<p>CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 <a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">여기</a>를 참조하라.</p>

<p>왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. <strong>모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다.</strong> CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다.</p>

<h2 id="모던-cmake의-예">모던 CMake의 예</h2>
<ul>
  <li>
    <p>잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다.</p>
  </li>
  <li>
    <p>CMake 3.1+가 필요한 경우 <strong>CXX_STANDARD</strong>를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 <strong>compile_features</strong>를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다.</p>
  </li>
  <li>
    <p>CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 <strong>compile_features</strong>를 사용하여 <strong>cxx_std_11</strong>과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다.</p>
  </li>
</ul>

<h1 id="2023년-최소한의-선택">2023년 최소한의 선택</h1>

<p>로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다.</p>

<p>지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다.</p>

<h2 id="선택할-최소-항목---os-지원">선택할 최소 항목 - OS 지원:</h2>

<ul>
  <li>3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라.</li>
  <li>3.7: Debian의 오래된 Stable.</li>
  <li>3.10: Ubuntu 18.04.</li>
  <li>3.11: CentOS 8(단, EPEL 또는 AppSteams 사용)</li>
  <li>3.13: Debian Stable.</li>
  <li>3.16: Ubuntu 20.04.</li>
  <li>3.19: 최초로 Apple Silicon을 지원.</li>
  <li>최신: pip/conda-forge/homebew/chocolaty 등</li>
</ul>

<h2 id="선택할-최소-항목---기능">선택할 최소 항목 - 기능:</h2>

<ul>
  <li>3.8: C++ 메타 기능, CUDA 등 다양한 기능</li>
  <li>3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE</li>
  <li>3.12: C++20, cmake –build build -j N, SHELL:, FindPython</li>
  <li>3.14/3.15: CLI, FindPython 업데이트</li>
  <li>3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능</li>
  <li>3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍</li>
  <li>3.20: C++23, CUDARCHS, IntelLLVM, NVHPC</li>
  <li>3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS</li>
  <li>3.24: 다운로드와 패키지 찾기 통합, –fresh</li>
  <li>3.25: C++26 지원, CUDA용 LTO</li>
</ul>

<h1 id="다른-소스들">다른 소스들</h1>

<p>웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다.</p>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/">Modern CMake</a>: 이 튜토리얼의 출처가 되는 책.</li>
  <li><a href="https://cmake.org/cmake/help/latest/">The official help</a>: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐.</li>
  <li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a>: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록.</li>
  <li><a href="https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/">Embracing Modern CMake</a>: 용어에 대한 좋은 설명이 포함된 게시물.</li>
  <li><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">It’s time to do CMake Right</a>: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음.</li>
  <li><a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/">The Ultimate Guide to Modern CMake</a>: 비슷한 의도를 지닌 약간 오래된 게시물.</li>
  <li><a href="https://youtu.be/y7ndUhdQuU8">More Modern CMake</a>: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다.</li>
  <li><a href="https://github.com/toeb/moderncmake">toeb/moderncmake</a>: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제</li>
</ul>

<h1 id="핵심사항">핵심사항</h1>

<ul>
  <li>빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다.</li>
  <li>빌드 시스템 생성기는 일반적인 관계를 설명한다.</li>
  <li>모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[Introduction Overview 질문 빌드 시스템(Build System)과 빌드 시스템 생성기(Build System Generator)의 차이점은 무엇인가? 목표 빌드 시스템 및 빌드 시스템 생성기에 대해 알아본다 CMake가 사용되는 이유를 이해한다. 최신 CMake가 더 좋다. 코드를 빌드하는 것은 어렵다. 코드의 각 부분을 빌드하려면 긴 명령어가 필요하다. 그리고 코드의 많은 부분에서 이 작업을 수행해야 한다. 그래서 사람들은 빌드 시스템을 생각해냈다. 여기에는 종속성을 설정하는 방법(예: 파일 B를 빌드하려면 파일 A를 빌드해야 함)과 각 파일 또는 파일 유형을 빌드하는 데 사용되는 명령을 저장하는 방법이 있었다. 이는 (주로) 언어 독립적이므로 거의 모든 빌드를 설정할 수 있다. 원하는 경우 make를 사용하여 LaTeX 문서를 작성할 수 있다. 몇가지 일반적인 빌드 시스템에는 make(전통적인 널리 사용되는 시스템), ninja(빌드 시스템 생성기 시대에 설계된 Google의 최신 시스템), Invoke(Python 시스템) 및 rake(Ruby make, Ruby 사용자를 위한 좋은 구문)가 포함된다. 그러나 이는 다음과 같다. 대부분 손으로 코딩 : 적절한 명령을 모두 알아야 한다. 플랫폼/컴파일러에 따라 다름: 컴파일러마다 명령어를 작성해야 한다. 종속성을 인식하지 못함: 라이브러리가 필요한 경우, 경로 등을 처리해야 한다. 확장하기가 어려움; 대신 IDE를 사용하고 싶다면 행운을 빈다. 빌드 시스템 생성기를 보자(간단히 설명하기 위해 BSG로 표시). 이들은 프로그래밍 언어 빌드의 개념을 이해한다. 일반적으로 일반적인 컴파일러, 언어, 라이브러리 및 출력 형식을 지원한다. 이는 보통 빌드 시스템(또는 IDE) 파일을 작성한 다음 실제 빌드를 수행하도록 한다. 가장 인기 있는 BSG는 CMake(Cross-Platform Make) 이다. 하지만 방금 보듯이 실제로는 make와 같은 카테고리가 아니다. 다른 BSG로는 Autotools(오래되고 유연성이 없음), Bazel(Google 제공), SCons(이전 Python 시스템), Meson(신형 Python 시스템, 매우 독선적) 등이 있다. 그러나 CMake는 IDE, 라이브러리 및 컴파일러를 통해 비교할 수 없는 지원을 제공한다. 또한 소규모 프로젝트에서 쉽게 선택할 수 있고(어쨌든 모던 CMake), CERN 실험과 같은 대규모 프로젝트에서 수천 개의 모듈에 사용할 수 있어 확장성이 매우 좋다. CMake와 Make 모두 Rake, SCon 등과 같이 기존 언어로 만들어진 게 아니라 사용자 정의 언어라는 점에 주목해라. 언어를 통합하는 것은 좋지만, 외부 언어를 설치하고 구성해야 한다는 요구 사항이 너무 높아 일반적으로 사용하기에는 충분하지 않았다. 요약하면 다음과 같은 경우 CMake를 사용해야 한다. 하드 코딩 경로를 피하고 싶은 경우 두 대 이상의 컴퓨터에서 패키지를 빌드해야할 경우 CI(지속적 통합)를 사용하고 싶은 경우 다양한 OS를 지원해야할 경우(어쩌면 Unix 버전일 수도 있음) 여러 컴파일러를 지원하고 싶은 경우 IDE를 사용하고 싶지만 항상 그렇지는 않을 경우 플래그나 명령이 아닌 프로그램이 논리적으로 어떻게 구성되어 있는지 설명하고 싶은 경우 라이브러리를 이용하고 싶은 경우 Clang-Tidy와 같은 도구를 사용하여 코딩을 돕고 싶은 경우 디버거를 사용하려는 경우 (More) Modern CMake CMake는 2000년경에 도입된 이후 정말 극적으로 변화했다. 그리고 2.8이 되었을 때 많은 Linux 배포 패키지 관리자에서 사용할 수 있었다. 하지만 이는 종종 환경에 “기본적으로 사용 가능한” 정말 오래된 버전의 CMake가 있음을 의미한다. 최신 CMake에 맞게 업그레이드하고 설계하라. 빌드 시스템을 작성하거나 디버깅하는 것을 좋아하는 사람은 아무도 없다. 최신 버전을 사용하면 빌드 시스템 코드를 절반 이하로 줄일 수 있고 버그를 줄이고, 외부 종속 항목과 더 효과적으로 통합할 수 있다. CMake 설치는 한 줄이면 충분하며 sudo 액세스가 필요하지 않다. 자세한 내용은 여기를 참조하라. 왠지 이해하기 어렵기 때문에 더 명확하게 외쳐보겠다. 모던 CMake를 작성하면 빌드 문제가 발생할 가능성이 줄어든다. CMake가 제공하는 도구는 여러분이 직접 작성하려고 하는 도구보다 더 좋다. CMake는 여러분보다 더 많은 상황에서 더 많은 컴파일러와 함께 작동한다. 플래그를 추가하려고 하면 일부 컴파일러나 OS에서는 잘못된 결과를 얻을 가능성이 있지만 CMake가 제공하는 도구를 대신 사용할 수 있다면, 올바른 플래그를 추가하는 것은 CMake의 몫이지 당신의 몫이 아니다. 모던 CMake의 예 잘못된 2.8 스타일 CMake: C++11 플래그를 수동으로 추가한다. 이는 컴파일러에 따라 다르며 CUDA와 다르며 최소 버전이 아닌 설정된 버전으로 고정된다. CMake 3.1+가 필요한 경우 CXX_STANDARD를 설정할 수 있지만 최종 타겟에만 설정할 수 있다. 또는 개별 C++11 및 C++14 기능에 대한 compile_features를 수동으로 나열할 수 있으며, 이를 사용하는 모든 타겟은 최소한 해당 수준으로 설정된다. CMake 3.8+가 필요한 경우 여러 기능을 수동으로 나열하는 대신 compile_features를 사용하여 cxx_std_11과 같은 최소 표준 수준을 설정할 수 있다. 이는 C++17 이상 C++20 및 C__23에만 사용되었다. 2023년 최소한의 선택 로컬에서 실행해야 하는 최소 CMake와 코드를 사용하는 사람들을 위해 지원해야 하는 최소 버전은 무엇일까? 이 글을 읽고 있다면 CMake의 마지막 몇 가지 버전에서 릴리스를 얻을 수 있을 것이다. 그렇게 하면 개발이 더 쉬워질 것이다. 지원을 위해 최소 버전을 선택하는 두 가지 방법이 있다. 즉, 추가된 기능(개발자가 관심을 갖는 부분)을 기반으로 하거나 사전 설치된 일반적인 CMake(사용자가 관심을 갖는 부분)를 기반으로 한다. 지원하는 가장 오래된 컴파일러 버전보다 오래된 최소 버전을 선택하지 말라. CMake는 항상 최소한 컴파일러만큼 새로운 것이어야 한다. 선택할 최소 항목 - OS 지원: 3.4: 최소한의 수준. 절대 이보다 낮게 설정하지 마라. 3.7: Debian의 오래된 Stable. 3.10: Ubuntu 18.04. 3.11: CentOS 8(단, EPEL 또는 AppSteams 사용) 3.13: Debian Stable. 3.16: Ubuntu 20.04. 3.19: 최초로 Apple Silicon을 지원. 최신: pip/conda-forge/homebew/chocolaty 등 선택할 최소 항목 - 기능: 3.8: C++ 메타 기능, CUDA 등 다양한 기능 3.11: 가져온 인터페이스 설정, 더 빨라짐, FetchContent, IDE의 COMPILE_LANGUAGE 3.12: C++20, cmake –build build -j N, SHELL:, FindPython 3.14/3.15: CLI, FindPython 업데이트 3.16: Unity 빌드/프리컴파일된 헤더, CUDA 메타 기능 3.17/3.18: 훨씬 더 많은 CUDA, 메타프로그래밍 3.20: C++23, CUDARCHS, IntelLLVM, NVHPC 3.21: 다양한 메시지 유형, MSVC 2022, C17 &amp; C23, HIP, MSYS 3.24: 다운로드와 패키지 찾기 통합, –fresh 3.25: C++26 지원, CUDA용 LTO 다른 소스들 웹에서 좋은 정보를 찾을 수 있는 다른 곳도 있다. 그 중 일부는 다음과 같다. Modern CMake: 이 튜토리얼의 출처가 되는 책. The official help: 정말 놀라운 문서이다. 잘 정리되어 있고 검색 기능이 뛰어나며 상단에서 버전을 전환할 수 있다. 이 책이 채우려고 하는 훌륭한 “모범 튜토리얼”이 없을 뿐. Effective Modern CMake: 해야 할 일과 하지 말아야 할 일의 훌륭한 목록. Embracing Modern CMake: 용어에 대한 좋은 설명이 포함된 게시물. It’s time to do CMake Right: 모던 CMake 프로젝트를 위한 훌륭한 모범 사례 모음. The Ultimate Guide to Modern CMake: 비슷한 의도를 지닌 약간 오래된 게시물. More Modern CMake: CMake 3.12+를 추천하는 Meeting C++ 2018의 훌륭한 프레젠테이션. 이 강연에서는 CMake 3.0+를 “Modern CMake” 및 CMake 3.12+ “More Modern CMake”라고 칭한다. toeb/moderncmake: 프로젝트 구성을 통한 구문 소개와 함께 CMake 3.5+에 대한 멋진 프레젠테이션 및 예제 핵심사항 빌드 시스템은 타겟을 빌드하는 방법을 정확하게 설명한다. 빌드 시스템 생성기는 일반적인 관계를 설명한다. 모던 CMake는 더 간단하며 빌드 문제가 발생할 가능성을 줄인다.]]></summary></entry><entry><title type="html">More Modern CMake</title><link href="http://localhost:4000/2024/01/15/00-more-modern-cmake.html" rel="alternate" type="text/html" title="More Modern CMake" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/2024/01/15/00-more-modern-cmake</id><content type="html" xml:base="http://localhost:4000/2024/01/15/00-more-modern-cmake.html"><![CDATA[<p>More Modern CMake 공부하려고 대충 번역함. 구글과 파파고 사용해서 내가 보기 쉽게 정리</p>

<p>출처 : <a href="https://hsf-training.github.io/hsf-training-cmake-webpage/">More Modern CMake</a></p>

<p>HSF CMake 튜토리얼에 오신 것을 환영한다! 이 튜토리얼의 목적은 CMake 사용의 기본 사항을 다루는 것이다. 이 튜토리얼은 CMake 3.15+에 초점을 맞춘 온라인 서적 Modern CMake를 기반으로 한다. 이것은 CMake의 “More Modern” 시대(대략 3.12+로 정의됨)에 해당하며 CMake π(3.14) 및 3.15의 환상적인 명령 개선이 포함된다. 이 글을 쓰는 시점의 현재 버전은 CMake 3.21이다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li><a href="/more-modern-cmake-introduction">Introduction</a></li>
  <li><a href="/more-modern-cmake-build-with-cmake">Building With CMake</a></li>
  <li><a href="/more-modern-cmake-your-first-file">Your first file CMakeLists.txt file</a></li>
  <li><a href="/more-modern-cmake-working-with-targets">Working with Targets</a></li>
  <li><a href="/more-modern-cmake-variables-explained">Variables explained</a></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="CMake" /><summary type="html"><![CDATA[More Modern CMake 공부하려고 대충 번역함. 구글과 파파고 사용해서 내가 보기 쉽게 정리 출처 : More Modern CMake HSF CMake 튜토리얼에 오신 것을 환영한다! 이 튜토리얼의 목적은 CMake 사용의 기본 사항을 다루는 것이다. 이 튜토리얼은 CMake 3.15+에 초점을 맞춘 온라인 서적 Modern CMake를 기반으로 한다. 이것은 CMake의 “More Modern” 시대(대략 3.12+로 정의됨)에 해당하며 CMake π(3.14) 및 3.15의 환상적인 명령 개선이 포함된다. 이 글을 쓰는 시점의 현재 버전은 CMake 3.21이다. 목차 Introduction Building With CMake Your first file CMakeLists.txt file Working with Targets Variables explained]]></summary></entry><entry><title type="html">Unity Prototype Step2</title><link href="http://localhost:4000/2023/10/26/18-unity-client-step2.html" rel="alternate" type="text/html" title="Unity Prototype Step2" /><published>2023-10-26T00:00:00+09:00</published><updated>2023-10-26T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/26/18-unity-client-step2</id><content type="html" xml:base="http://localhost:4000/2023/10/26/18-unity-client-step2.html"><![CDATA[<h1 id="2-캐릭터-클래스-정의">2. 캐릭터 클래스 정의</h1>
<ul>
  <li>프로토타입에 사용될 예제들은 페이지 마지막에 정리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : type // 인간,드워프
  Class : type // 전사, 성직자
  Level : uint // 레벨
  Movement : uint //이동 가능 칸수
  CurrentHitPoint : uint //현재 HP
  MaxHitPoint : uint //최대 HP
  Strength : uint // 힘, 일단 1
  AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스
  AttackRange : uint //공격범위, 근거리일 경우는 1
  ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11
  WeaponType : type //한손
  WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage)
}
</code></pre></div></div>

<h1 id="3-두-캐릭터의-hp-표시하기">3. 두 캐릭터의 HP 표시하기</h1>

<ul>
  <li>Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-hpbar.png" alt="캐릭터 HP" /></p>

<h1 id="4-커맨드-메뉴-구현하기">4. 커맨드 메뉴 구현하기</h1>

<ul>
  <li>해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행</li>
  <li>한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-menu.png" alt="캐릭터 메뉴" /></p>

<h2 id="1-이동">1. 이동</h2>

<ul>
  <li>이동 메뉴를 선택시 <a href="/unity-prototype-step1">이전페이지</a> 와 동일하게 이동할 수 있는 영역이 표시됨</li>
  <li>영역은 Character Class의 Movement 값을 적용하여 표시</li>
  <li>영역 클릭시 해당 타일로 이동</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-move.png" alt="캐릭터 이동" /></p>

<h2 id="2-공격">2. 공격</h2>

<ul>
  <li>영역은 Character Class의 AttackRange 값을 적용하여 표시</li>
  <li>영역 클릭시 아래 공격 로직을 적용</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step2-attack.png" alt="캐릭터 공격" /></p>

<h2 id="3-대기">3. 대기</h2>

<ul>
  <li>따로 영역 필요없이 상대방에게 턴을 넘김</li>
</ul>

<h1 id="5-공격-적용">5. 공격 적용</h1>
<ul>
  <li>이번에는 따로 무기없이 한손, 근거리 전투로만 한정</li>
</ul>

<h2 id="명중-굴림">명중 굴림</h2>

<ul>
  <li>공격이 성공하는지 체크하는 로직으로 <strong>공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공</strong></li>
  <li>
    <p><a href="/basic-fantasy/encounter#공격하기">Basic Fantasy - 조우</a>의 공격하기 설명 참고</p>
  </li>
  <li>명중 굴림 성공 유무 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="피해">피해</h2>

<ul>
  <li>명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영</li>
  <li>
    <p><a href="/basic-fantasy/encounter#피해">Basic Fantasy - 조우</a>의 피해 설명 참고</p>
  </li>
  <li>피해 산정 수식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>피해 = Math.Rand(WeaponDamage) + Strength
</code></pre></div>    </div>
  </li>
  <li>상대편 HP 적용, 상대편 HPBar에 업데이트
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CurrentHitPoint = CurrentHitPoint - 피해
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="공격턴-마무리">공격턴 마무리</h2>

<ul>
  <li>상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리</li>
</ul>

<h1 id="5-프로토타입에-적용할-chracter-예제-데이터">5. 프로토타입에 적용할 Chracter 예제 데이터</h1>
<ul>
  <li>드워프/전사</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Dwarf
  Class : Fighter
  Level : 1
  Movement : 2
  CurrentHitPoint : 15
  MaxHitPoint : 15
  Strength : 2
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 6
}
</code></pre></div></div>

<ul>
  <li>인간/성직자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Character
{
  Race : Human
  Class : Cleric
  Level : 1
  Movement : 1
  CurrentHitPoint : 12
  MaxHitPoint : 12
  Strength : 1
  AttackBonus : 1
  AttackRange : 1
  ArmorClass : 11
  WeaponType : OneHand
  WeaponDamage : 4
}
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[2. 캐릭터 클래스 정의 프로토타입에 사용될 예제들은 페이지 마지막에 정리 Character { Race : type // 인간,드워프 Class : type // 전사, 성직자 Level : uint // 레벨 Movement : uint //이동 가능 칸수 CurrentHitPoint : uint //현재 HP MaxHitPoint : uint //최대 HP Strength : uint // 힘, 일단 1 AttackBonus : uint //직업과 레벨에 따로 부가 공격 보너스 AttackRange : uint //공격범위, 근거리일 경우는 1 ArmorClass : uint //AC, 갑옷의 방어력, 갑옷이 없을 경우 11 WeaponType : type //한손 WeaponDamage : uint //무기의 최대 데미지(1~WeaponDamage) } 3. 두 캐릭터의 HP 표시하기 Character Class에 HP 프로퍼티를 적용하고, 해당 데이터를 View에서 백분율로 각 캐릭터의 머리위에 HP Bar로 표시 4. 커맨드 메뉴 구현하기 해당 턴의 캐릭터에 명령을 내릴 때 이동 명령이 아니라, 이동,공격,대기 명령을 선택하여 각 명령에 맞게 실행 한 번의 턴에서는 3개의 명령 중 하나만 선택할 수 있으며, 선택 후 실행이 끝나면 상대방 턴으로 변경 1. 이동 이동 메뉴를 선택시 이전페이지 와 동일하게 이동할 수 있는 영역이 표시됨 영역은 Character Class의 Movement 값을 적용하여 표시 영역 클릭시 해당 타일로 이동 2. 공격 영역은 Character Class의 AttackRange 값을 적용하여 표시 영역 클릭시 아래 공격 로직을 적용 3. 대기 따로 영역 필요없이 상대방에게 턴을 넘김 5. 공격 적용 이번에는 따로 무기없이 한손, 근거리 전투로만 한정 명중 굴림 공격이 성공하는지 체크하는 로직으로 공격자의 공격력이 상대편의 방어력(AC)보다 크면 공격 성공 Basic Fantasy - 조우의 공격하기 설명 참고 명중 굴림 성공 유무 수식 Math.Rand(20) + Strength + AttackBonus &gt;= 상대편 AC 피해 명중 굴림이 성공하면 WeaponDamage 굴림하여 상대편에게 피해를 주고, 이 피해는 상대편의 HP에 반영 Basic Fantasy - 조우의 피해 설명 참고 피해 산정 수식 피해 = Math.Rand(WeaponDamage) + Strength 상대편 HP 적용, 상대편 HPBar에 업데이트 CurrentHitPoint = CurrentHitPoint - 피해 공격턴 마무리 상대편 CurrentHitPoint가 0이 되면, 게임 오버 처리 5. 프로토타입에 적용할 Chracter 예제 데이터 드워프/전사 Character { Race : Dwarf Class : Fighter Level : 1 Movement : 2 CurrentHitPoint : 15 MaxHitPoint : 15 Strength : 2 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 6 } 인간/성직자 Character { Race : Human Class : Cleric Level : 1 Movement : 1 CurrentHitPoint : 12 MaxHitPoint : 12 Strength : 1 AttackBonus : 1 AttackRange : 1 ArmorClass : 11 WeaponType : OneHand WeaponDamage : 4 }]]></summary></entry><entry><title type="html">Dotnetty Prototype Step3</title><link href="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step3" /><published>2023-10-12T00:00:00+09:00</published><updated>2023-10-12T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3</id><content type="html" xml:base="http://localhost:4000/2023/10/12/21-dotnetty-server-prototype-step3.html"><![CDATA[<h1 id="인스턴스-메신저-구현하기">인스턴스 메신저 구현하기</h1>
<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/InstantMessenger">github project</a></li>
  <li><a href="https://github.com/SoonPoong-Hong/hong-netty-messenger">Netty로 구현된 원래 프로젝트</a></li>
</ul>

<h2 id="기능-패킷-타입--enum-e_action-참고">기능 (패킷 타입) : enum E_ACTION 참고</h2>
<ul>
  <li>LOGIN  //로그인</li>
  <li>LOGOUT //로그아웃</li>
  <li>ENTER_TO_ROOM //방 입장 요청</li>
  <li>EXIT_FROM_ROOM //방 퇴장 요청</li>
  <li>TALK_MESSAGE //메시지 톡 전송</li>
  <li>ROOM_LIST //방 목록</li>
  <li>USER_LIST //방 사람들 목록</li>
  <li>RESPONSE_SUCCESS //성공 – 서버 응답으로 사용</li>
  <li>RESPONSE_FAIL //실패 – 서버 응답으로 사용</li>
</ul>

<h2 id="클라이언트-명령">클라이언트 명령</h2>
<ul>
  <li>LOGIN은 실행과 동시에 같이 처리됨으로 생략</li>
  <li>위의 패킷 타입과 동일</li>
</ul>

<h3 id="단일명령">단일명령</h3>
<ul>
  <li>끝에 :만 붙여서 처리</li>
  <li>LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST:</li>
</ul>

<h3 id="파라메터명령">파라메터명령</h3>
<ul>
  <li>: 뒤에 파라메터를 붙여 처리</li>
  <li>TALK_MESSAGE:<strong>전달할 메시지</strong></li>
  <li>ENTER_TO_ROOM:<strong>들아걸 방이름</strong></li>
</ul>

<h2 id="패킷-구조">패킷 구조</h2>
<ul>
  <li>
    <p>MessagePacket/PacketHelper 클래스 참조</p>
  </li>
  <li>Header
    <ul>
      <li>= 로 시작하고 = 로 끝남</li>
      <li>key:value로 선언되고, 각 라인은 CRLF 로 처리</li>
      <li>length:XXXX 는 Body의 길이, length가 0이면 contents가 없다.</li>
    </ul>
  </li>
  <li>Body
    <ul>
      <li>문자열로 이루어진 데이터</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>
<ul>
  <li>LOGIN 패킷의 경우 : Body가 없음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
LOGIN
length:0
refId:1
refName:nick
=
</code></pre></div>    </div>
  </li>
  <li>USER_LIST 패킷의 경우
    <ul>
      <li>[“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다.
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=
USER_LIST
length:5
=
["1"]
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="pipeline-설명--클라-서버-클라">Pipeline 설명 : 클라-&gt;서버-&gt;클라</h2>
<ul>
  <li>클라 전송
    <ol>
      <li>부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화)</li>
      <li>Connect</li>
      <li>ClientConsoleInput 클래스에서 유저 입력을 받음</li>
      <li>bootstrap channel의 WriteAndFlushAsync 메소드 호출</li>
      <li>MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨</li>
    </ol>
  </li>
  <li>서버 수신
    <ol>
      <li>MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성</li>
      <li>MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리</li>
      <li>그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨</li>
      <li>처리된 결과를 <strong>클라 전송 4/5 항목과 동일하게 실행</strong>하여 전송</li>
    </ol>
  </li>
</ul>

<h2 id="서버클라이언트-콘솔-실행">서버/클라이언트 콘솔 실행</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-im-server-client.png" alt="서버-클라이언트 콘솔" /></li>
</ul>

<h3 id="서버-실행">서버 실행</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMServer
</code></pre></div></div>

<h3 id="클라-실행">클라 실행</h3>
<ul>
  <li>./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 1 nick
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./IMClient 2 choi
</code></pre></div></div>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><category term="InstantMessenger" /><summary type="html"><![CDATA[인스턴스 메신저 구현하기 소스코드 github project Netty로 구현된 원래 프로젝트 기능 (패킷 타입) : enum E_ACTION 참고 LOGIN //로그인 LOGOUT //로그아웃 ENTER_TO_ROOM //방 입장 요청 EXIT_FROM_ROOM //방 퇴장 요청 TALK_MESSAGE //메시지 톡 전송 ROOM_LIST //방 목록 USER_LIST //방 사람들 목록 RESPONSE_SUCCESS //성공 – 서버 응답으로 사용 RESPONSE_FAIL //실패 – 서버 응답으로 사용 클라이언트 명령 LOGIN은 실행과 동시에 같이 처리됨으로 생략 위의 패킷 타입과 동일 단일명령 끝에 :만 붙여서 처리 LOGOUT:, EXIT_FROM_ROOM:, ROOM_LIST:, USER_LIST: 파라메터명령 : 뒤에 파라메터를 붙여 처리 TALK_MESSAGE:전달할 메시지 ENTER_TO_ROOM:들아걸 방이름 패킷 구조 MessagePacket/PacketHelper 클래스 참조 Header = 로 시작하고 = 로 끝남 key:value로 선언되고, 각 라인은 CRLF 로 처리 length:XXXX 는 Body의 길이, length가 0이면 contents가 없다. Body 문자열로 이루어진 데이터 예시 LOGIN 패킷의 경우 : Body가 없음 = LOGIN length:0 refId:1 refName:nick = USER_LIST 패킷의 경우 [“1”] 부분이 Body 내용이고 Length는 이 Body의 길이이다. = USER_LIST length:5 = ["1"] Pipeline 설명 : 클라-&gt;서버-&gt;클라 클라 전송 부트스트랩 실행시 MessageClientInitializer 실행 (Receive Pipeline 초기화) Connect ClientConsoleInput 클래스에서 유저 입력을 받음 bootstrap channel의 WriteAndFlushAsync 메소드 호출 MessagePacketEncoder 를 통해서 MessagePacket이 byte[]로 encode 되어서 전송됨 서버 수신 MessagePacketDecoder.Decode 메소드 안에서 byte[]에서 HEADER Decode 후, length를 가지고 다시한번 Body를 Decode 하여 MessagePacket 을 생성 MessagePacket이 E_ACTION.LOGIN 일 경우는 ServerLoginProcessHandler 호출하여 로그인 처리 그 외의 경우는 MessageServerReceiveHandler 클래스안에서 Action 에 따라 각각 처리됨 처리된 결과를 클라 전송 4/5 항목과 동일하게 실행하여 전송 서버/클라이언트 콘솔 실행 서버 실행 &gt; ./IMServer 클라 실행 ./IMClient ID Name : ID가 중복되면 이미 로그인되어 있다고 오류가 출력됨 &gt; ./IMClient 1 nick &gt; ./IMClient 2 choi]]></summary></entry><entry><title type="html">Dotnetty Prototype Step2</title><link href="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html" rel="alternate" type="text/html" title="Dotnetty Prototype Step2" /><published>2023-10-05T00:00:00+09:00</published><updated>2023-10-05T00:00:00+09:00</updated><id>http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2%20copy</id><content type="html" xml:base="http://localhost:4000/2023/10/05/20-dotnetty-server-prototype-step2-copy.html"><![CDATA[<h1 id="채팅-프로그램으로-오델로-게임-구현하기">채팅 프로그램으로 오델로 게임 구현하기</h1>
<ul>
  <li><a href="/dotnetty-server-prototype-step1">채팅 구현</a>의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현</li>
  <li>채팅과 동일하게 서버 한대와 클라이언트 두대로 구성</li>
</ul>

<h2 id="게임-규칙">게임 규칙</h2>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/오델로#규칙">오델로#규칙</a> 참조</li>
  <li>첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현)</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<ul>
  <li><a href="https://github.com/snowpipe-dev/DotNettyServerSamples/tree/main/Othello">github project</a></li>
  <li>프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중</li>
</ul>

<h2 id="구현규칙">구현규칙</h2>
<h3 id="패킷">패킷</h3>
<ul>
  <li>채팅에서 사용한 StringEncoder/StringDecoder를 사용</li>
  <li>포멧
    <ul>
      <li><strong>CommandKey</strong>::<strong>CommandValue</strong></li>
      <li>예) Put::5,4 // 5,4에 돌을 놓아둡니다.</li>
    </ul>
  </li>
</ul>

<h4 id="commandkey">CommandKey</h4>
<h5 id="client--유저가-내릴-수-있는-명령">Client : 유저가 내릴 수 있는 명령</h5>
<ul>
  <li><em>Join</em> : <em>자동 명령</em>, 닉네임 입력하면 자동으로 서버에 등록됩니다.</li>
  <li>Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다.</li>
  <li>Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다.</li>
</ul>

<h5 id="server--서버에서-판단하여-전파하는-명령">Server : 서버에서 판단하여 전파하는 명령</h5>
<ul>
  <li>CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령</li>
  <li>StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령</li>
  <li>TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령</li>
  <li>Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령</li>
  <li>Members : 현재 접속한 구성원들을 알려주는 명령</li>
  <li>FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨</li>
  <li>SuccessPut : Put 명령이 문제없이 실행되었을 때 응답</li>
  <li>FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력</li>
  <li>NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송</li>
</ul>

<h3 id="클라이언트">클라이언트</h3>
<ul>
  <li>소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs</li>
</ul>

<ol>
  <li>클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함</li>
  <li>입력받은 내용을 패킷을 통해 모두 서버로 전송</li>
  <li>즉, 클라이언트에서는 판단하는 로직이 없음</li>
</ol>

<h3 id="서버">서버</h3>
<ul>
  <li>소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs</li>
</ul>

<ol>
  <li>서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한</li>
  <li>각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행</li>
  <li>그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작</li>
</ol>

<h2 id="구현중-발견된-문제점">구현중 발견된 문제점</h2>
<ul>
  <li>패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생
    <ul>
      <li>다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인  <strong>|</strong> 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리
        <ul>
          <li>처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ]
            <ol>
              <li>SuccessPut 처리</li>
              <li>FlipTiles 처리</li>
              <li>NextTurn 처리</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡
    <ul>
      <li>여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용)</li>
    </ul>
  </li>
  <li>클라이언트 콘솔 문제
    <ul>
      <li>오델로 판을 파악하기 어려움</li>
    </ul>
  </li>
</ul>

<h2 id="오델로-서버클라이언트-콘솔화면">오델로 서버/클라이언트 콘솔화면</h2>
<ul>
  <li><img src="/assets/images/prototype/prototype-dotnetty-step2-othello.png" alt="서버-클라이언트 오델로 콘솔" /></li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Dotnetty" /><category term="Server" /><category term="Prototype" /><summary type="html"><![CDATA[채팅 프로그램으로 오델로 게임 구현하기 채팅 구현의 Server/Client 소스를 그대로 가져고 와서 확장하여 1:1 오델로 게임 구현 채팅과 동일하게 서버 한대와 클라이언트 두대로 구성 게임 규칙 오델로#규칙 참조 첫번째와 두번째 규칙만 구현됨 (패스, 게임 종료, 승리 판단 여부는 아직 미구현) 소스코드 github project 프로토타이핑이기 때문에 최적화와 하드 코딩은 신경쓰지 않고 구현에 집중 구현규칙 패킷 채팅에서 사용한 StringEncoder/StringDecoder를 사용 포멧 CommandKey::CommandValue 예) Put::5,4 // 5,4에 돌을 놓아둡니다. CommandKey Client : 유저가 내릴 수 있는 명령 Join : 자동 명령, 닉네임 입력하면 자동으로 서버에 등록됩니다. Start : 첫번째 Join 유저가 Host 되어 게임 시작할 수 있으나, 단 구성원이 두명이어야 합니다. Put : 게임 시작후 각자 턴에 특정 좌표에 돌을 놓아둡니다. Server : 서버에서 판단하여 전파하는 명령 CompleteJoin : Join이 성공적으로 처리되었을 때의 응답명령 StartGame : Host 클라이언트의 Start 명령을 받으면 오델로 판을 초기화 후 응답 명령 TileType : StartGame 후 각 클라이언트이 돌 색깔을 알려주는 명령 Message : Message 뒤의 CommandValue를 클라이언트에서 출력하도록 명령 Members : 현재 접속한 구성원들을 알려주는 명령 FailPut : 클라이언트의 Put 명령 CommandValue 유효성 실패했을 때, 그 뒤에 오류가 붙어서 전송됨 SuccessPut : Put 명령이 문제없이 실행되었을 때 응답 FlipTiles : SuccessPut 이후 뒤집어질 돌들의 좌표들을 전송, 클라이언트는 오델로 판에 맞게 출력 NextTurn : FlipTiles 처리 후, 다음 턴의 클라이언트를 지정하여 전송 클라이언트 소스코드 : /Othello/OthelloClient/OthelloClientHandler.cs 클라이언트들은 유저로부터 입력만 받고, 내부 로직을 처리안함 입력받은 내용을 패킷을 통해 모두 서버로 전송 즉, 클라이언트에서는 판단하는 로직이 없음 서버 소스코드 : /Othello/OthelloServer/OthelloServerHandler.cs 서버는 클라이언트들이 접속하고 게임 시작 후 오델로 판을 생성한 각 클라이언트들에게 턴을 부여하고, 해당 턴에 전송받은 내용의 유효성을 검사, 명령(CommandKey)을 실행 그 결과값을 다시 전체 클라이언트에 전송하고(SendMessage/BroadCast) 2부터 다시 시작 구현중 발견된 문제점 패킷단위로 전송되는게 아니라, Tcp 특성상 Stream 으로 전송되다보니 여러패킷이 같이 보내져서 클라이언트에서 Decode하면서 오류 발생 다음 스텝에서 해결할 예정이나 일단 패킷 끝날때 구분자인 | 을 붙여서, Decode할 때 Split 하여 여러 패킷을 분리하여 순차적으로 처리 처리 예) Packet[ SuccessPut::5,4,BLACK|FlipTiles::BLACK#4,4|NextTurn::0| ] SuccessPut 처리 FlipTiles 처리 NextTurn 처리 위의 오델로 규칙 참고 문서를 보면 판정하는 로직이 복잡 여기서는 최적화 신경쓰지 않고 생각나는 데로 처리 (짐승 알고리즘 보다 조금 나은 방법 사용) 클라이언트 콘솔 문제 오델로 판을 파악하기 어려움 오델로 서버/클라이언트 콘솔화면]]></summary></entry><entry><title type="html">Unity Prototype Step1</title><link href="http://localhost:4000/unity-prototype-step1" rel="alternate" type="text/html" title="Unity Prototype Step1" /><published>2023-09-27T00:00:00+09:00</published><updated>2023-09-27T00:00:00+09:00</updated><id>http://localhost:4000/15-unity-client-step1</id><content type="html" xml:base="http://localhost:4000/unity-prototype-step1"><![CDATA[<h1 id="1-두-캐릭터를-그리드-안에서-이동하기">1. 두 캐릭터를 그리드 안에서 이동하기</h1>
<ul>
  <li>10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기</li>
  <li>단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨</li>
</ul>

<p><img src="/assets/images/prototype/prototype-unity-step1-movement.png" alt="캐릭터 이동" /></p>

<h2 id="데이터">데이터</h2>
<ul>
  <li>드워프/전사 : 가로,세로 2칸씩 이동(파란색)</li>
  <li>인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색)</li>
</ul>

<h2 id="플로우">플로우</h2>
<ol>
  <li>드워프 선택됨</li>
  <li>해당 드워프의 이동 가능 거리가 표시</li>
  <li>이동가능한 그리드를 선택하면 드워프 이동</li>
  <li>성직자 선택됨</li>
  <li>2,3 동일하게 반복</li>
  <li>1부터 다시 시작</li>
</ol>

<h2 id="데이터구조">데이터구조</h2>
<ul>
  <li>2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것.</li>
  <li>즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서)</li>
</ul>

<h2 id="나중에">나중에…</h2>
<ul>
  <li><a href="/2023/09/25/10-basic-fantasy-pregenerated-characters.html">미리 생성된 캐릭터들</a> 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획</li>
</ul>]]></content><author><name>nickchoi</name></author><category term="C#" /><category term="Unity" /><category term="Client" /><category term="Prototype" /><summary type="html"><![CDATA[1. 두 캐릭터를 그리드 안에서 이동하기 10x10 그리드에 두 캐릭터를 놓고 서로 한번씩 이동하기 단, 그리드를 넘어갈 수 없고, 두 캐릭터가 겹쳐도 안됨 데이터 드워프/전사 : 가로,세로 2칸씩 이동(파란색) 인간/성직자 : 가로,세로 1칸씩 이동(핫핑크색) 플로우 드워프 선택됨 해당 드워프의 이동 가능 거리가 표시 이동가능한 그리드를 선택하면 드워프 이동 성직자 선택됨 2,3 동일하게 반복 1부터 다시 시작 데이터구조 2차원 배열로 캐릭터들 위치 저장하고, 충돌판정할 것. 즉 데이터로만 처리하고 GameObject로 처리하지 않는다 (차후 서버 연동시에 데이터와 로직, View 분리위해서) 나중에… 미리 생성된 캐릭터들 데이터의 movement로 대체해서 개별 캐릭터마다 이동거리를 데이터로 처리할 계획]]></summary></entry></feed>