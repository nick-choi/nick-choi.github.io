---
layout: article
title: More Modern CMake - Building with CMake
tags: CMake
permalink: /more-modern-cmake-build-with-cmake
---

# Building With CMake

## Overview

* 질문
  * 프로젝트를 어떻게 빌드하는가?

* 목표
  * CMake 설치에 대한 참고.
  * 기존 프로젝트를 빌드하는 방법을 알아보자.
  * 빌드를 사용자 정의한다.
  * 몇 가지 기본적인 디버깅을 수행하는 방법을 알아보자.

## CMake 설치

거의 모든 곳에 최신 버전의 CMake를 설치하는 데 일반적으로 한 줄 또는 두 줄에 불과하다. [CMake 설명](https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html)을 참조.

## CMake 로 빌드하기

CMake를 작성하기 전에 CMake를 실행하여 만드는 방법을 알고 있는지 확인하겠다. 이는 거의 모든 CMake 프로젝트에 해당된다.

### Try it out

프로젝트를 하나 가져와서 빌드해 보자. 재미삼아 CLI11을 빌드해본다.

```
git clone https://github.com/CLIUtils/CLI11.git
cd CLI11
```

이제 새로 다운로드된 디렉토리에서 모던 CMake(3.14) 빌드 절차를 시도해보자.

```
cmake -S . -B build
cmake --build build
cmake --build build -t test
```

빌드 디렉터리(**-B**)가 존재하지 않을 경우 빌드 디렉터리를 만들고, 소스 디렉터리는 **-S**로 정의한다. CMake는 기본적으로 makefile을 구성하고 생성할 뿐만 아니라 모든 옵션을 기본 설정으로 설정하고 이를 빌드 디렉터리에 있는 **CMakeCache.txt**라는 파일에 캐시한다. 관례적으로 대부분의 패키지의 **.gitignore** 파일에서 무시하려면 **build**라는 단어가 있어야 한다.

그런 다음 빌드 시스템을 호출할 수 있다(2번째 줄). **make**(기본값), **ninja** 또는 IDE 기반 시스템을 사용했는지 여부에 관계없이 동일한 명령을 사용하여 빌드할 수 있다. **-j 2**를 추가하여 두 개의 코어에 빌드하거나 **-v**를 추가하여 빌드에 사용된 명령을 자세히 표시할 수 있다.

마지막으로 "test" 대상을 기본 빌드 시스템에 전달하여 여기에서 테스트를 실행할 수도 있다. **-t**(CMake 3.15 이전에는 **--target**)를 사용하면 대상을 선택할 수 있다. CMake 3.15+에는 기본 빌드 시스템을 호출하지 않고 설치를 수행하는 **cmake \<dir\> --install** 명령도 있다!

### 소스 안에서 빌드하는 것의 경고

소스 디렉토리에서 절대로 "소스 내" 빌드 - 즉, **cmake .** 를 실행하면 안된다. 소스 디렉토리를 빌드 결과물, CMake 구성 파일로 오염시키고 소스 외부 빌드를 비활성화한다. 몇 개의 패키지는 소스 디렉토리가 빌드 디렉토리 내부에 위치하는 것조차 허용하지 않는다. 그런 경우 상대 경로(**..**)를 적절히 변경해야 한다.

간단히 설명하자면, CMake는 빌드 디렉토리의 소스 디렉토리 또는 어디에서나 기존 빌드 디렉토리를 가리킬 수 있다.

### 다른 구문 선택

완전성을 위해 고전적인 방법이 보여주는 것이 좋겠다.
```
mkdir build
cd build
cmake ..
make
make test
```

여기에는 몇 가지 단점이 있다. 디렉터리가 이미 존재하는 경우 **-p**를 추가해야 하지만 Windows에서는 작동하지 않는다. 당신은 그 디렉토리 안에 있기 때문에 빌드 디렉토리 사이를 쉽게 변경할 수 없다. 라인이 더 많아지고, 빌드 디렉터리로 변경하는 것을 잊어버린 경우 **cmake ..** 대신 **cmake .** 를 사용한다. 그럴 경우 소스 디렉토리를 오염시킬 수 있다.

## 컴파일러 선택하기

컴파일러 선택은 빈 디렉터리에서 처음 실행할 때 수행되어야 한다. CMake 구문 자체는 아니지만 익숙하지 않을 수도 있다. Clang을 선택하려면:
```
CC=clang CXX=clang++ cmake -S . -B build
```

그러면 **CC** 및 **CXX**에 대해 bash에서 환경 변수로 설정되고 CMake는 해당 변수를 고려할 것이다. 이렇게 하면 해당 한 라인에 대해서만 설정되지만, 필요한 경우는 딱 저 시간 뿐이다. 이후 CMake는 해당 값에서 추론한 경로를 계속 사용한다.


## 생성기 선택하기

다양한 툴을 사용하여 빌드할 수 있다. **make**는 일반적으로 기본값이다. CMake가 시스템에서 알고 있는 모든 툴을 보려면 다음을 실행하자.
```
cmake --help
```

그리고 **-G"My Tool"**을 사용하여 툴을 선택할 수 있다(툴 이름에 공백이 있는 경우에만 큰따옴표가 필요). 컴파일러와 마찬가지로 디렉터리에서 처음 CMake 호출 시 툴을 선택해야 한다. **build** 및 **build-xcode**와 같이 여러 빌드 디렉터리를 자유롭게 사용할 수 있다. 환경 변수 **CMAKE_GENERATOR**를 설정하여 기본 생성기(CMake 3.15+)를 조작할 수 있다. makefile은 **make -j2**와 같이 명시적으로 여러 스레드를 전달하는 경우에만 병렬로 실행되는 반면, Ninja는 자동으로 병렬로 실행된다. 최근 버전의 CMake에서도 **-j 2**와 같은 병렬화 옵션을 **cmake --build .** 명령에 직접 전달할 수 있다.

## 옵션 설정하기

**-D**를 사용하여 CMake에서 옵션을 설정한다. **-L**을 사용하면 옵션 목록을 볼 수 있고, **-LH**를 사용하면 사람이 읽을 수 있는 도움말 목록을 볼 수 있다.

## 상세 및 부분 빌드

다시 말하지만, CMake는 아니지만 **make**와 같은 커맨드 라인 빌드 툴을 사용하는 경우, 자세한 빌드를 얻을 수 있다:
```
cmake --build build -v
```
make를 직접 사용하는 경우, **VERBOSE=1 make** 또는 **make VERBOSE=1**이라고 쓸 수 있으며, 비록 명령 뒤에 변수를 쓰는 것은 **make**의 기능이고 일반적인 커맨드 라인 방식이 아니지만, make 역시 올바른 작업을 수행할 것이다.

CMake에서 정의한 라이브러리 또는 실행 파일의 이름과 같은 대상을 지정하여 빌드의 일부만 빌드할 수도 있으며 make는 해당 대상만 빌드한다. 이것이 **--target**(CMake 3.15+에서는 **-t**) 옵션이다.

## 옵션들

CMake는 캐시된 옵션을 지원한다. CMake의 변수는 "캐시됨"으로 표시될 수 있는데, 이 의미는 변수가 발견되면 캐시(빌드 디렉터리에 있는 **CMakeCache.txt**라는 파일)에 기록된다는 의미이다. **-D**를 사용하여 커맨드라인에서 캐시된 옵션 값을 미리 설정(또는 변경)할 수 있다. CMake가 캐시된 변수를 찾을 때는 기존 값을 사용하고 덮어쓰지 않는다.

### 표준 옵션들

이는 대부분의 패키지에 대한 일반적인 CMake 옵션들이다:
* **CMAKE_BUILD_TYPE**: **Release**, **RelWithDebInfo**, **Debug** 등에서 선택
* **CMAKE_INSTALL_PREFIX**: 설치할 위치. UNIX의 시스템 설치는 종종 **/usr/local**(기본값)이고, 사용자 디렉터리는 대개 **~/.local**이거나 폴더를 선택할 수 있다.
* **BUILD_SHARED_LIBS**: **ON** 또는 **OFF**로 설정하여 공유 라이브러리의 기본값을 제어할 수 있다. (단, 작성자는 기본값을 사용하는 대신 명시적으로 둘 중 하나를 선택할 수 있다)
* **BUILD_TESTING**: 이는 테스트를 활성화하기 위한 일반적인 이름이다. 다만 때때로 적절한 이유로 인해 모든 패키지에서 이를 사용하는 것은 아니다.

### 시도해보기

복제한 CLI11 저장소에서:

* 어떤 옵션을 사용할 수 있는지 확인
* 값을 변경한다; **CMAKE_CXX_STANDARD**를 14로 설정하거나 테스트를 끌 수도 있다.
* **CMAKE_INSTALL_PREFIX=install**로 구성한 다음 해당 로컬 디렉터리에 설치한다. 거기에서 보여지는 지 확인하라!

## CMake 파일들 디버깅

이미 빌드에 대한 자세한 출력을 언급했지만 자세한 CMake 구성 출력도 볼 수 있다. **--trace** 옵션은 실행되는 CMake의 모든 라인을 인쇄한다. 이것은 매우 장황하기 때문에, CMake 3.7에는 **--trace-source="filename"**을 추가하여 실행 시 관심있는 파일의 모든 실행 라인을 출력한다. 디버깅에 관심이 있는 파일 이름을 선택하면(CMakeLists.txt를 디버깅하는 경우 모든 이름이 동일하므로 일반적으로 상위 디렉터리 사용) 해당 파일에서 실행되는 라인만 볼 수 있다. 굉장히 유용하다!

### 시도해보기

소스 디렉터리에서 다음을 실행한다:
```
cmake build --trace-source="CMakeLists.txt"
```

### 답해보자.

질문: **cmake build**는 무엇이든 빌드하는가?
답 : 아니, 여기서 "빌드"는 디렉터리이다. 이것은 (빌드 시스템 파일을) 구성한다. 빌드하려면 디렉터리 앞에 **--build**를 추가하거나 **make**와 같은 빌드 툴을 사용한다.

### 더 읽어보기

[Modern CMake intro/running](https://cliutils.gitlab.io/modern-cmake/chapters/intro/running.html)을 기반으로 함.

## 핵심사항

* 프로젝트를 빌드.
* 소스 외부 빌드를 사용하자.
* 빌드 옵션 및 사용자 정의.
* CMakeList를 쉽게 디버그.